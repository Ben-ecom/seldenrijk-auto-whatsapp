# 📋 Multi-Channel AI Engagement Platform - PRD v5.0

**Generated by SDK AGENTS Complete Workflow**
**Date**: January 2025
**Version**: 5.0 (Dual UI: Chatwoot + Next.js Dashboard)
**Status**: ✅ VALIDATED BY EVP - Score 7.2/10 - APPROVED WITH CONDITIONS
**Architecture**: Dual UI (Operations in Chatwoot + Marketing in Next.js)

---

## 🎯 Executive Summary

### Evolution: v4.0 → v5.0

**v4.0** → LangGraph multi-agent system with Chatwoot multi-channel inbox
**v5.0** → **Dual UI architecture** + **9 comprehensive use cases** + **Advanced marketing automation**

### What's New in v5.0?

**ARCHITECTURE CHANGE:**
- 🆕 **Dual UI System**: Chatwoot (operations) + Next.js dashboard (marketing)
- 🆕 **Shared Supabase Database**: Single source of truth
- 🆕 **Webhook Synchronization**: Real-time updates between UIs
- 🆕 **Role-Based Access**: Operations team vs Marketing team

**NEW USE CASES (5 additions to v4.0's 4 existing):**
1. ✅ Analytics Dashboard (real-time metrics, campaign performance)
2. ✅ Multi-Agent Research (parallel Claude agents, web scraping)
3. ✅ Resend Email Marketing (AI campaigns, segmentation)
4. ✅ Form/Survey/Quiz Builder (drag-drop, AI auto-tagging)
5. ✅ CRM with Advanced Segmentation (behavior-based targeting)

**EXISTING USE CASES (Enhanced from v4.0):**
6. ✅ WhatsApp Marketing Campaigns (from v4.0, enhanced)
7. ✅ Instagram DM Marketing (from v4.0, enhanced)
8. ✅ Agentic RAG (from v3.0, enhanced with "agentic" framing)
9. ✅ Chatwoot Multi-Channel Inbox (from v4.0, unchanged)

### Key Capabilities Matrix

| Feature | v3.0 | v4.0 | v5.0 |
|---------|------|------|------|
| **Channels** | WhatsApp | Multi-channel | Multi-channel |
| **UI Architecture** | Single (Reflex) | Single (Chatwoot + widgets) | **Dual (Chatwoot + Next.js)** |
| **Marketing Tools** | None | Campaigns | **Campaigns + Email + Forms** |
| **Analytics** | Basic | Chatwoot reports | **Custom BI dashboard** |
| **CRM** | Basic | Chatwoot CRM | **Advanced segmentation** |
| **Research** | None | None | **Multi-agent parallel** |
| **Email Marketing** | None | None | **Resend integration** |
| **Form Builder** | None | None | **Drag-drop + AI tagging** |

---

## 🏗️ System Architecture Overview

### Dual UI Architecture

```
┌──────────────────────────────────────────────────────────┐
│                   USER ROLES                              │
│                                                           │
│  OPERATIONS TEAM (5-10 people)    MARKETING TEAM (2-3)   │
│  • Customer support               • Campaign management   │
│  • Live chat                      • Analytics            │
│  • Human takeover                 • Email marketing      │
│  • Contact management             • Form building        │
│                                                           │
│  Uses: CHATWOOT UI                Uses: NEXT.JS DASHBOARD│
└─────────────┬───────────────────────────┬────────────────┘
              │                           │
              ↓                           ↓
┌──────────────────────────┐   ┌──────────────────────────┐
│    CHATWOOT              │   │    NEXT.JS DASHBOARD     │
│    (Operations UI)       │   │    (Marketing UI)        │
│                          │   │                          │
│ • Multi-channel inbox    │   │ • Analytics dashboard    │
│ • WhatsApp conversations │   │ • Campaign builder       │
│ • Instagram DM inbox     │   │ • Email marketing        │
│ • Email inbox            │   │ • Form/quiz builder      │
│ • SMS inbox              │   │ • CRM segmentation       │
│ • Team collaboration     │   │ • Research agents        │
│ • Contact CRM            │   │ • Agent monitoring       │
│ • Tags & labels          │   │ • RAG knowledge base     │
│ • Human takeover         │   │                          │
└─────────────┬────────────┘   └─────────────┬────────────┘
              │                               │
              └───────────┬───────────────────┘
                          ↓
              ┌───────────────────────┐
              │  SHARED SUPABASE DB   │
              │  (Single Source)      │
              │                       │
              │ • leads               │
              │ • messages            │
              │ • campaigns           │
              │ • forms               │
              │ • segments            │
              │ • knowledge_base      │
              │ • conversation_state  │
              └──────────┬────────────┘
                         ↓
              ┌───────────────────────┐
              │  INTEGRATION LAYER    │
              │                       │
              │ • Webhooks            │
              │   (Chatwoot → FastAPI)│
              │ • Real-time Sync      │
              │   (Supabase subscr.)  │
              │ • Polling             │
              │   (Campaign status)   │
              └──────────┬────────────┘
                         ↓
              ┌───────────────────────┐
              │  FASTAPI BACKEND      │
              │  (Orchestration)      │
              │                       │
              │ • Webhook handlers    │
              │ • API endpoints       │
              │ • LangGraph runtime   │
              └──────────┬────────────┘
                         ↓
              ┌───────────────────────┐
              │  LANGGRAPH            │
              │  (Multi-Agent Brain)  │
              │                       │
              │ • Router Agent        │
              │ • 6 Specialized Agents│
              │ • State Management    │
              └───────────────────────┘
```

### Component Communication

```
CHATWOOT UI:
- Displays conversations from all channels
- Operations team responds to customers
- Updates contact CRM (tags, notes)
- Triggers webhooks on events
- Reads from Supabase (contact data)

    ↕ WEBHOOKS + DATABASE SYNC ↕

NEXT.JS DASHBOARD:
- Displays analytics (real-time)
- Creates campaigns (WhatsApp, Instagram, Email)
- Builds forms/quizzes
- Manages CRM segments
- Monitors agent activity
- Reads/writes to Supabase

    ↕ SHARED DATABASE ↕

SUPABASE:
- Single source of truth
- Real-time subscriptions
- Row-level security (RLS)
- PGVector (embeddings)

    ↕ API CALLS ↕

FASTAPI BACKEND:
- Receives Chatwoot webhooks
- Exposes REST API for Next.js
- Orchestrates LangGraph workflows
- Manages Celery background jobs

    ↕ INVOKE WORKFLOWS ↕

LANGGRAPH:
- Router Agent (classify intent)
- Agent 1 (Extraction - Pydantic AI)
- Agent 2 (Conversation - Claude)
- Agent 3 (Campaigns - Claude)
- Agent 4 (CRM - GPT-4o-mini)
- Agent 5 (Research - Multi-Claude)
- Agent 6 (Email - Claude + Resend)
- Agent 7 (Form Processing - GPT-4o-mini)
```

---

## 🤖 Agent Architecture (7 Specialized Agents)

### Agent Overview

| Agent | Model | Purpose | Trigger | Cost/Use |
|-------|-------|---------|---------|----------|
| **Router** | GPT-4o-mini | Priority + intent classification | Every message | $0.001 |
| **Agent 1** | GPT-4o-mini | Structured extraction (Pydantic AI) | Every 5 msgs | $0.003 |
| **Agent 2** | Claude 3.5 Sonnet | Natural conversation + tool use | Every message | $0.15/conv |
| **Agent 3** | Claude 3.5 Sonnet | Campaign generation (WhatsApp/Instagram) | Manual launch | $0.10/DM |
| **Agent 4** | GPT-4o-mini | CRM automation (stock alerts, tags) | Agent decision | $0.001/op |
| **Agent 5** | Claude 3.5 Sonnet (multi) | Multi-agent research | Manual launch | $0.50/research |
| **Agent 6** | Claude 3.5 Sonnet | Email marketing (Resend integration) | Manual launch | $0.08/email |
| **Agent 7** | GPT-4o-mini | Form response processing | Form submission | $0.002/response |

### LangGraph State Machine (Enhanced from v4.0)

```python
class ConversationState(TypedDict):
    """Enhanced state for v5.0 with new use cases"""

    # Message context (unchanged from v4.0)
    message_id: str
    conversation_id: str
    customer_id: str
    channel: Literal["whatsapp", "instagram", "email", "sms", "telegram", "webchat"]
    message_content: str
    message_type: Literal["incoming", "outgoing"]

    # AI analysis (unchanged from v4.0)
    intent: str  # "product_inquiry", "complaint", "stock_alert", "research_request", etc.
    priority: Literal["high", "medium", "low"]
    sentiment: float  # -1.0 to 1.0

    # Routing decisions (unchanged from v4.0)
    route: str  # "agent", "human", "automated"
    needs_human: bool
    escalation_reason: Optional[str]

    # Agent responses (unchanged from v4.0)
    agent_response: Optional[str]
    tools_used: List[str]

    # CRM data (unchanged from v4.0)
    customer_profile: Dict
    conversation_history: List[Dict]
    tags: List[str]
    follow_up_needed: bool
    follow_up_date: Optional[datetime]

    # Campaign context (unchanged from v4.0)
    is_campaign_message: bool
    campaign_id: Optional[str]

    # Stock alert context (unchanged from v4.0)
    product_interest: Optional[str]
    stock_alert_requested: bool

    # NEW v5.0: Email marketing context
    email_campaign_id: Optional[str]
    email_tracking: Dict  # {opened: bool, clicked: bool, replied: bool}

    # NEW v5.0: Form/quiz context
    form_submission_id: Optional[str]
    form_responses: Dict  # {field_name: value}
    auto_tags_suggested: List[str]  # AI-generated tags from form

    # NEW v5.0: Research context
    research_task_id: Optional[str]
    research_agents_active: int  # Number of parallel agents
    research_findings: List[Dict]  # Results from research agents

    # NEW v5.0: Segment tracking
    segment_ids: List[str]  # Which CRM segments this contact belongs to
    segment_match_score: float  # How well contact matches target segment
```

---

## 🔧 NEW USE CASES (v5.0 Additions)

### Use Case 1: Analytics Dashboard (NEW)

**Problem Solved**: Operations team can't see campaign performance, agent metrics, or conversion funnels in real-time.

**Solution**: Custom Next.js analytics dashboard with real-time data from Supabase.

**UI Location**: Next.js Dashboard → Analytics page

**Features**:
- **Real-time Metrics**:
  - Conversations today/week/month
  - Response time (avg, p50, p95, p99)
  - Agent utilization (% auto-handled vs human)
  - Channel breakdown (WhatsApp, Instagram, Email)
- **Campaign Performance**:
  - DMs sent vs responses
  - Conversion rate by campaign
  - Best-performing products
  - Channel effectiveness
- **Agent Performance**:
  - Router accuracy (correctly classified)
  - Agent 2 conversation length (avg messages)
  - Tool usage frequency (search_products, check_stock, etc.)
  - Escalation rate (agent → human handoff)
- **Revenue Tracking**:
  - Lead → Qualified → Customer funnel
  - Conversion by source channel
  - Average deal value
  - Monthly recurring revenue (if subscription)

**Database Tables**:
```sql
CREATE TABLE analytics_events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    event_type VARCHAR(100) NOT NULL,  -- "message_received", "campaign_sent", "conversion", etc.
    event_data JSONB NOT NULL,
    occurred_at TIMESTAMPTZ DEFAULT NOW(),

    -- Dimensions for filtering
    channel VARCHAR(50),
    campaign_id UUID,
    agent_id VARCHAR(50),  -- "router", "agent_2", "agent_3", etc.
    customer_id UUID,

    -- Metadata
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_analytics_events_type ON analytics_events(event_type);
CREATE INDEX idx_analytics_events_occurred_at ON analytics_events(occurred_at);
CREATE INDEX idx_analytics_events_channel ON analytics_events(channel);
```

**Next.js Dashboard Component**:
```typescript
// app/analytics/page.tsx
export default function AnalyticsPage() {
  const { data: metrics } = useRealtimeMetrics()

  return (
    <div className="grid grid-cols-4 gap-6 p-6">
      {/* Top Row: Key Metrics */}
      <MetricCard
        title="Conversations Today"
        value={metrics.conversationsToday}
        change={+12.5}
        trend="up"
      />
      <MetricCard
        title="Avg Response Time"
        value="2.3s"
        change={-0.7}
        trend="down"  // Lower is better
      />
      <MetricCard
        title="Auto-Handled Rate"
        value="82%"
        change={+5}
        trend="up"
      />
      <MetricCard
        title="Conversion Rate"
        value="14.2%"
        change={+2.1}
        trend="up"
      />

      {/* Second Row: Charts */}
      <div className="col-span-2">
        <Card>
          <CardHeader>
            <CardTitle>Conversations by Channel (Last 7 Days)</CardTitle>
          </CardHeader>
          <CardContent>
            <LineChart data={metrics.conversationsByChannel} />
          </CardContent>
        </Card>
      </div>

      <div className="col-span-2">
        <Card>
          <CardHeader>
            <CardTitle>Campaign Performance</CardTitle>
          </CardHeader>
          <CardContent>
            <BarChart data={metrics.campaignPerformance} />
          </CardContent>
        </Card>
      </div>

      {/* Third Row: Agent Performance */}
      <div className="col-span-4">
        <Card>
          <CardHeader>
            <CardTitle>Agent Performance Matrix</CardTitle>
          </CardHeader>
          <CardContent>
            <DataTable
              columns={[
                { header: "Agent", accessorKey: "agent_name" },
                { header: "Messages Handled", accessorKey: "messages_handled" },
                { header: "Avg Response Time", accessorKey: "avg_response_time" },
                { header: "Escalation Rate", accessorKey: "escalation_rate" },
                { header: "Customer Satisfaction", accessorKey: "csat_score" },
              ]}
              data={metrics.agentPerformance}
            />
          </CardContent>
        </Card>
      </div>
    </div>
  )
}
```

**Real-time Sync**:
```typescript
// hooks/useRealtimeMetrics.ts
import { useEffect, useState } from 'react'
import { createClient } from '@supabase/supabase-js'

export function useRealtimeMetrics() {
  const [metrics, setMetrics] = useState(null)

  useEffect(() => {
    const supabase = createClient(...)

    // Subscribe to analytics_events table
    const subscription = supabase
      .channel('analytics_events')
      .on('postgres_changes',
        { event: 'INSERT', schema: 'public', table: 'analytics_events' },
        (payload) => {
          // Update metrics in real-time
          updateMetrics(payload.new)
        }
      )
      .subscribe()

    return () => {
      subscription.unsubscribe()
    }
  }, [])

  return { data: metrics, isLoading: !metrics }
}
```

---

### Use Case 2: Multi-Agent Research (NEW)

**Problem Solved**: Marketing team needs to research competitors, gather contact info, or analyze market trends, but manual research takes hours.

**Solution**: Deploy 3-5 Claude agents in parallel to research web, scrape data, and compile findings.

**UI Location**: Next.js Dashboard → Research page

**Agent Architecture**:
```python
class ResearchAgent:
    """Agent 5: Multi-agent parallel research orchestrator"""

    async def spawn_research_swarm(
        self,
        task: str,
        num_agents: int = 3,
        max_results_per_agent: int = 10
    ) -> ResearchResults:
        """
        Spawn multiple Claude agents to research in parallel

        Example task:
        "Research top 10 Dutch beauty salons in Amsterdam hiring for receptionist positions.
         For each salon, find: name, website, email, phone, Instagram handle."
        """

        # 1. Break task into subtasks (one per agent)
        subtasks = await self.decompose_research_task(task, num_agents)

        # 2. Spawn agents in parallel
        research_tasks = [
            self.research_agent_worker(subtask, agent_id=i)
            for i, subtask in enumerate(subtasks)
        ]

        # 3. Gather results
        results = await asyncio.gather(*research_tasks)

        # 4. Compile + deduplicate
        compiled = await self.compile_research_results(results)

        return compiled

    async def research_agent_worker(
        self,
        subtask: str,
        agent_id: int
    ) -> List[Dict]:
        """
        Single agent performs web research

        Tools available:
        - web_search (via Serper API or similar)
        - web_scrape (extract content from URLs)
        - extract_contact_info (email, phone detection)
        """

        # Use Claude with tools
        response = await anthropic.messages.create(
            model="claude-3-5-sonnet-20241022",
            messages=[{
                "role": "user",
                "content": f"Research task: {subtask}\n\nUse web_search and web_scrape tools to gather data."
            }],
            tools=[
                {"name": "web_search", ...},
                {"name": "web_scrape", ...},
                {"name": "extract_contact_info", ...}
            ],
            max_tokens=4000
        )

        # Extract structured data from agent's findings
        findings = await self.parse_research_findings(response)

        return findings
```

**Database Tables**:
```sql
CREATE TABLE research_tasks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    title VARCHAR(255) NOT NULL,
    description TEXT NOT NULL,
    num_agents INTEGER DEFAULT 3,

    -- Status
    status VARCHAR(50) DEFAULT 'pending',  -- "pending", "running", "completed", "failed"
    progress INTEGER DEFAULT 0,  -- 0-100%

    -- Results
    results JSONB,  -- Compiled research findings
    findings_count INTEGER DEFAULT 0,

    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    started_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,

    -- Metadata
    created_by VARCHAR(255),
    estimated_duration_seconds INTEGER
);

CREATE TABLE research_agent_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    research_task_id UUID REFERENCES research_tasks(id),
    agent_id INTEGER NOT NULL,  -- 0, 1, 2, etc.

    -- Agent activity
    subtask TEXT,
    findings JSONB,
    web_searches INTEGER DEFAULT 0,
    pages_scraped INTEGER DEFAULT 0,

    -- Status
    status VARCHAR(50),
    error_message TEXT,

    -- Timestamps
    started_at TIMESTAMPTZ DEFAULT NOW(),
    completed_at TIMESTAMPTZ
);
```

**Next.js Dashboard UI**:
```typescript
// app/research/page.tsx
export default function ResearchPage() {
  const [taskDescription, setTaskDescription] = useState('')
  const [numAgents, setNumAgents] = useState(3)
  const { tasks, createTask } = useResearchTasks()

  return (
    <div className="p-6">
      <Card>
        <CardHeader>
          <CardTitle>Multi-Agent Research</CardTitle>
          <CardDescription>
            Deploy AI agents to research the web in parallel
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            <div>
              <Label>Research Task Description</Label>
              <Textarea
                placeholder="e.g., Research top 10 beauty salons in Amsterdam hiring for receptionist. Find name, website, email, phone, Instagram."
                value={taskDescription}
                onChange={(e) => setTaskDescription(e.target.value)}
                rows={4}
              />
            </div>

            <div>
              <Label>Number of Agents (3-5 recommended)</Label>
              <Slider
                min={1}
                max={5}
                step={1}
                value={[numAgents]}
                onValueChange={([value]) => setNumAgents(value)}
              />
              <p className="text-sm text-gray-500 mt-1">
                {numAgents} agents will research in parallel
              </p>
            </div>

            <Button
              onClick={() => createTask({
                description: taskDescription,
                numAgents
              })}
              disabled={!taskDescription}
            >
              <Search className="mr-2 h-4 w-4" />
              Start Research
            </Button>
          </div>
        </CardContent>
      </Card>

      {/* Active research tasks */}
      <div className="mt-8">
        <h2 className="text-2xl font-bold mb-4">Research Tasks</h2>
        {tasks.map(task => (
          <ResearchTaskCard key={task.id} task={task} />
        ))}
      </div>
    </div>
  )
}

function ResearchTaskCard({ task }) {
  return (
    <Card className="mb-4">
      <CardHeader>
        <div className="flex justify-between items-start">
          <div>
            <CardTitle>{task.title}</CardTitle>
            <CardDescription>{task.description}</CardDescription>
          </div>
          <Badge variant={task.status === 'completed' ? 'success' : 'default'}>
            {task.status}
          </Badge>
        </div>
      </CardHeader>
      <CardContent>
        {task.status === 'running' && (
          <div>
            <Progress value={task.progress} className="mb-2" />
            <p className="text-sm text-gray-600">
              {task.progress}% complete ({task.findings_count} findings so far)
            </p>

            {/* Real-time agent activity */}
            <div className="mt-4 space-y-2">
              {task.agents.map(agent => (
                <div key={agent.id} className="flex items-center text-sm">
                  <div className="w-20">Agent {agent.id}</div>
                  <div className="flex-1">
                    <div className="h-2 bg-gray-200 rounded">
                      <div
                        className="h-2 bg-blue-500 rounded animate-pulse"
                        style={{ width: `${agent.progress}%` }}
                      />
                    </div>
                  </div>
                  <div className="ml-4 text-gray-600">
                    {agent.pages_scraped} pages scraped
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}

        {task.status === 'completed' && (
          <div>
            <p className="text-green-600 mb-4">
              ✅ Research complete! Found {task.findings_count} results
            </p>
            <Button onClick={() => downloadResults(task.id)}>
              <Download className="mr-2 h-4 w-4" />
              Download Results (CSV)
            </Button>
          </div>
        )}
      </CardContent>
    </Card>
  )
}
```

---

### Use Case 3: Resend Email Marketing (NEW)

**Problem Solved**: Manual email campaigns are time-consuming and don't leverage AI for personalization.

**Solution**: AI-powered email marketing with Resend API integration, segment targeting, and auto-personalization.

**UI Location**: Next.js Dashboard → Email Marketing page

**Agent Architecture**:
```python
class EmailMarketingAgent:
    """Agent 6: Email campaign generation + Resend integration"""

    async def create_email_campaign(
        self,
        subject: str,
        segment_ids: List[str],
        personalization_fields: List[str],
        template: str
    ) -> EmailCampaign:
        """
        Create personalized email campaign

        Args:
            subject: Email subject line
            segment_ids: Which CRM segments to target
            personalization_fields: Fields to personalize (name, product_interest, etc.)
            template: Base email template
        """

        # 1. Get target contacts from segments
        contacts = await self.get_segment_contacts(segment_ids)

        # 2. For each contact, generate personalized email
        personalized_emails = []
        for contact in contacts:
            # Use Claude to personalize
            personalized_content = await self.personalize_email(
                template=template,
                contact=contact,
                fields=personalization_fields
            )

            personalized_emails.append({
                "to": contact.email,
                "subject": subject,
                "html": personalized_content,
                "tags": [f"campaign_{campaign_id}", f"segment_{segment_id}"]
            })

        # 3. Send via Resend (batch API)
        await self.send_via_resend(personalized_emails)

        # 4. Track in database
        campaign = await self.create_campaign_record(
            segment_ids=segment_ids,
            emails_sent=len(personalized_emails)
        )

        return campaign

    async def personalize_email(
        self,
        template: str,
        contact: Contact,
        fields: List[str]
    ) -> str:
        """Use Claude to personalize email for specific contact"""

        prompt = f"""
        Personalize this email template for a customer:

        Template:
        {template}

        Customer Info:
        - Name: {contact.name}
        - Product Interest: {contact.product_interest}
        - Last Interaction: {contact.last_interaction_date}
        - Purchase History: {contact.purchase_history}

        Personalize the template naturally. Keep the same structure but make it feel personal.
        Don't add new sections, just personalize existing content.
        """

        response = await claude.messages.create(
            model="claude-3-5-sonnet-20241022",
            messages=[{"role": "user", "content": prompt}],
            max_tokens=1000
        )

        return response.content[0].text

    async def send_via_resend(self, emails: List[Dict]):
        """Send emails via Resend API"""

        from resend import Resend
        resend = Resend(api_key=os.getenv("RESEND_API_KEY"))

        # Batch send (Resend supports up to 100 per request)
        for batch in self.chunk_list(emails, 100):
            response = resend.emails.batch.send(batch)

            # Track sends in database
            await self.track_email_sends(response)
```

**Database Tables**:
```sql
CREATE TABLE email_campaigns (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    subject VARCHAR(500) NOT NULL,
    template TEXT NOT NULL,

    -- Targeting
    segment_ids UUID[],  -- Array of segment IDs
    target_count INTEGER,

    -- Status
    status VARCHAR(50) DEFAULT 'draft',  -- "draft", "scheduled", "sending", "sent", "paused"
    sent_count INTEGER DEFAULT 0,
    opened_count INTEGER DEFAULT 0,
    clicked_count INTEGER DEFAULT 0,
    replied_count INTEGER DEFAULT 0,

    -- Metrics
    open_rate DECIMAL(5,2),
    click_rate DECIMAL(5,2),
    reply_rate DECIMAL(5,2),

    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    scheduled_at TIMESTAMPTZ,
    sent_at TIMESTAMPTZ,

    -- Metadata
    created_by VARCHAR(255),
    personalization_fields TEXT[]
);

CREATE TABLE email_campaign_recipients (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email_campaign_id UUID REFERENCES email_campaigns(id),
    customer_id UUID REFERENCES leads(id),

    -- Email details
    recipient_email VARCHAR(255) NOT NULL,
    subject VARCHAR(500),
    content TEXT,  -- Personalized content

    -- Resend tracking
    resend_email_id VARCHAR(255),  -- Resend's unique ID

    -- Status
    status VARCHAR(50) DEFAULT 'pending',  -- "pending", "sent", "delivered", "bounced", "failed"
    error_message TEXT,

    -- Engagement tracking
    opened BOOLEAN DEFAULT FALSE,
    opened_at TIMESTAMPTZ,
    clicked BOOLEAN DEFAULT FALSE,
    clicked_at TIMESTAMPTZ,
    replied BOOLEAN DEFAULT FALSE,
    replied_at TIMESTAMPTZ,

    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ
);

CREATE INDEX idx_email_recipients_campaign ON email_campaign_recipients(email_campaign_id);
CREATE INDEX idx_email_recipients_customer ON email_campaign_recipients(customer_id);
```

**Resend Webhook Handler**:
```python
@app.post("/webhooks/resend")
async def resend_webhook(event: dict):
    """
    Handle Resend webhook events for tracking

    Events:
    - email.sent: Email successfully sent
    - email.delivered: Email delivered to inbox
    - email.opened: Customer opened email
    - email.clicked: Customer clicked link
    - email.bounced: Email bounced
    """

    if event["type"] == "email.opened":
        # Update recipient record
        await db.execute(
            """
            UPDATE email_campaign_recipients
            SET opened = TRUE, opened_at = NOW()
            WHERE resend_email_id = $1
            """,
            event["data"]["email_id"]
        )

        # Update campaign stats
        await db.execute(
            """
            UPDATE email_campaigns
            SET opened_count = opened_count + 1,
                open_rate = (opened_count::DECIMAL / sent_count) * 100
            WHERE id = (
                SELECT email_campaign_id FROM email_campaign_recipients
                WHERE resend_email_id = $1
            )
            """,
            event["data"]["email_id"]
        )

    elif event["type"] == "email.clicked":
        # Track clicks
        await db.execute(
            """
            UPDATE email_campaign_recipients
            SET clicked = TRUE, clicked_at = NOW()
            WHERE resend_email_id = $1
            """,
            event["data"]["email_id"]
        )

    return {"status": "ok"}
```

---

### Use Case 4: Form/Survey/Quiz Builder (NEW)

**Problem Solved**: Marketing team can't easily create onboarding forms, surveys, or quizzes that integrate with CRM.

**Solution**: Drag-drop form builder with AI auto-tagging of responses.

**UI Location**: Next.js Dashboard → Forms page

**Features**:
- **Drag-drop form builder** (similar to Typeform/Google Forms)
- **Multiple field types**: Text, email, phone, multiple choice, rating, file upload
- **Conditional logic**: Show field X only if field Y = "value"
- **AI auto-tagging**: Agent 7 analyzes responses and suggests CRM tags
- **CRM integration**: Submissions auto-create contacts in Supabase
- **Embed anywhere**: Generate embed code for website

**Database Tables**:
```sql
CREATE TABLE forms (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    title VARCHAR(255) NOT NULL,
    description TEXT,

    -- Form definition
    fields JSONB NOT NULL,  -- Array of field definitions
    settings JSONB,  -- {allow_multiple_submissions, require_email, etc.}

    -- Styling
    theme JSONB,  -- {primary_color, font, logo_url, etc.}

    -- Status
    status VARCHAR(50) DEFAULT 'draft',  -- "draft", "published", "closed"

    -- Metrics
    views INTEGER DEFAULT 0,
    submissions INTEGER DEFAULT 0,
    completion_rate DECIMAL(5,2),

    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    published_at TIMESTAMPTZ,

    -- Metadata
    created_by VARCHAR(255)
);

CREATE TABLE form_submissions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    form_id UUID REFERENCES forms(id),

    -- Submitter info
    customer_id UUID,  -- If identified
    submitter_email VARCHAR(255),
    submitter_ip VARCHAR(45),

    -- Response data
    responses JSONB NOT NULL,  -- {field_id: value}

    -- AI analysis
    auto_tags TEXT[],  -- Tags suggested by Agent 7
    sentiment_score DECIMAL(3,2),  -- -1.0 to 1.0
    interest_keywords TEXT[],

    -- Status
    processed BOOLEAN DEFAULT FALSE,
    crm_synced BOOLEAN DEFAULT FALSE,

    -- Timestamps
    submitted_at TIMESTAMPTZ DEFAULT NOW(),
    processed_at TIMESTAMPTZ
);

CREATE INDEX idx_form_submissions_form ON form_submissions(form_id);
CREATE INDEX idx_form_submissions_customer ON form_submissions(customer_id);
```

**Agent 7: Form Processing**:
```python
class FormProcessingAgent:
    """Agent 7: Analyzes form submissions and auto-tags contacts"""

    async def process_form_submission(
        self,
        form_id: str,
        submission_id: str
    ):
        """
        Process form submission:
        1. Analyze responses with AI
        2. Generate CRM tags
        3. Create/update contact in Supabase
        4. Sync to Chatwoot
        """

        # 1. Get submission data
        submission = await self.get_submission(submission_id)
        form = await self.get_form(form_id)

        # 2. Use GPT-4o-mini to analyze responses
        analysis = await self.analyze_responses(submission, form)

        # 3. Generate tags
        auto_tags = analysis["suggested_tags"]
        interest_keywords = analysis["interest_keywords"]
        sentiment = analysis["sentiment_score"]

        # 4. Create/update contact
        contact_id = await self.upsert_contact(
            email=submission["email"],
            name=submission.get("name"),
            tags=auto_tags,
            custom_attributes={
                "form_submission_id": submission_id,
                "interests": interest_keywords,
                "sentiment": sentiment
            }
        )

        # 5. Sync to Chatwoot
        await self.sync_to_chatwoot(contact_id)

        return {"contact_id": contact_id, "tags": auto_tags}

    async def analyze_responses(
        self,
        submission: Dict,
        form: Dict
    ) -> Dict:
        """Use AI to analyze form responses"""

        prompt = f"""
        Analyze this form submission and suggest CRM tags:

        Form: {form["title"]}
        Description: {form["description"]}

        Responses:
        {json.dumps(submission["responses"], indent=2)}

        Based on these responses:
        1. Suggest 3-5 relevant CRM tags (e.g., "Curly Hair", "Price Sensitive", "Urgent")
        2. Extract interest keywords (products/services mentioned)
        3. Analyze sentiment (-1.0 to 1.0)

        Return JSON format:
        {{
          "suggested_tags": ["tag1", "tag2", "tag3"],
          "interest_keywords": ["keyword1", "keyword2"],
          "sentiment_score": 0.8
        }}
        """

        response = await openai.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}],
            response_format={"type": "json_object"}
        )

        return json.loads(response.choices[0].message.content)
```

---

### Use Case 5: CRM with Advanced Segmentation (NEW)

**Problem Solved**: Chatwoot CRM has basic tags, but marketing team needs behavior-based segmentation for targeted campaigns.

**Solution**: Advanced CRM segmentation in Next.js dashboard with dynamic rules.

**UI Location**: Next.js Dashboard → CRM → Segments page

**Features**:
- **Dynamic segments**: Auto-update as contacts match rules
- **Complex rules**: Combine multiple conditions (AND/OR logic)
- **Behavior-based**: Segment by actions (opened email, clicked link, purchased product)
- **Time-based**: "Contacted in last 30 days", "No interaction in 90 days"
- **Custom attributes**: Segment by any Supabase column

**Database Tables**:
```sql
CREATE TABLE segments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,

    -- Segment definition
    rules JSONB NOT NULL,  -- Complex rule engine
    match_type VARCHAR(10) DEFAULT 'all',  -- "all" (AND) or "any" (OR)

    -- Metrics
    contact_count INTEGER DEFAULT 0,
    last_calculated TIMESTAMPTZ,

    -- Status
    is_dynamic BOOLEAN DEFAULT TRUE,  -- Auto-update or static
    status VARCHAR(50) DEFAULT 'active',

    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),

    -- Metadata
    created_by VARCHAR(255),
    color VARCHAR(7)  -- Hex color for UI
);

CREATE TABLE segment_memberships (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    segment_id UUID REFERENCES segments(id),
    contact_id UUID REFERENCES leads(id),

    -- Tracking
    added_at TIMESTAMPTZ DEFAULT NOW(),
    match_score DECIMAL(3,2),  -- How well contact matches segment (0-1)

    UNIQUE(segment_id, contact_id)
);

CREATE INDEX idx_segment_memberships_segment ON segment_memberships(segment_id);
CREATE INDEX idx_segment_memberships_contact ON segment_memberships(contact_id);
```

**Segment Rule Engine**:
```typescript
// Segment rule format (JSONB)
{
  "match_type": "all",  // "all" (AND) or "any" (OR)
  "conditions": [
    {
      "field": "tags",
      "operator": "contains",
      "value": "VIP"
    },
    {
      "field": "last_contacted",
      "operator": "within_days",
      "value": 30
    },
    {
      "field": "email_opened",
      "operator": "equals",
      "value": true
    },
    {
      "field": "product_interest",
      "operator": "equals",
      "value": "Hair Care"
    }
  ]
}

// SQL generation from rules:
SELECT DISTINCT l.id
FROM leads l
LEFT JOIN email_campaign_recipients ecr ON l.id = ecr.customer_id
WHERE
  'VIP' = ANY(l.tags)  -- Condition 1
  AND l.last_contacted >= NOW() - INTERVAL '30 days'  -- Condition 2
  AND ecr.opened = TRUE  -- Condition 3
  AND l.product_interest = 'Hair Care'  -- Condition 4
```

**Next.js Dashboard UI**:
```typescript
// app/crm/segments/page.tsx
export default function SegmentsPage() {
  const { segments, createSegment } = useSegments()

  return (
    <div className="p-6">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold">Customer Segments</h1>
        <Dialog>
          <DialogTrigger asChild>
            <Button>
              <Plus className="mr-2 h-4 w-4" />
              Create Segment
            </Button>
          </DialogTrigger>
          <DialogContent className="max-w-2xl">
            <SegmentBuilder onSave={createSegment} />
          </DialogContent>
        </Dialog>
      </div>

      <div className="grid grid-cols-3 gap-4">
        {segments.map(segment => (
          <SegmentCard key={segment.id} segment={segment} />
        ))}
      </div>
    </div>
  )
}

function SegmentCard({ segment }) {
  return (
    <Card>
      <CardHeader>
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <div
              className="w-3 h-3 rounded-full"
              style={{ backgroundColor: segment.color }}
            />
            <CardTitle>{segment.name}</CardTitle>
          </div>
          <Badge variant="outline">{segment.contact_count} contacts</Badge>
        </div>
        <CardDescription>{segment.description}</CardDescription>
      </CardHeader>
      <CardContent>
        {/* Show rules summary */}
        <div className="text-sm text-gray-600 space-y-1">
          {segment.rules.conditions.map((condition, i) => (
            <div key={i}>
              • {condition.field} {condition.operator} {condition.value}
            </div>
          ))}
        </div>

        <div className="mt-4 flex gap-2">
          <Button size="sm" variant="outline" onClick={() => viewContacts(segment.id)}>
            View Contacts
          </Button>
          <Button size="sm" onClick={() => createCampaign(segment.id)}>
            Create Campaign
          </Button>
        </div>
      </CardContent>
    </Card>
  )
}

function SegmentBuilder({ onSave }) {
  const [rules, setRules] = useState({
    match_type: 'all',
    conditions: []
  })

  return (
    <div className="space-y-4">
      <div>
        <Label>Segment Name</Label>
        <Input placeholder="e.g., VIP Customers" />
      </div>

      <div>
        <Label>Match Type</Label>
        <RadioGroup value={rules.match_type} onValueChange={(value) => {
          setRules({ ...rules, match_type: value })
        }}>
          <div className="flex items-center space-x-2">
            <RadioGroupItem value="all" id="all" />
            <Label htmlFor="all">Match ALL conditions (AND)</Label>
          </div>
          <div className="flex items-center space-x-2">
            <RadioGroupItem value="any" id="any" />
            <Label htmlFor="any">Match ANY condition (OR)</Label>
          </div>
        </RadioGroup>
      </div>

      <div>
        <Label>Conditions</Label>
        <div className="space-y-2">
          {rules.conditions.map((condition, index) => (
            <RuleCondition
              key={index}
              condition={condition}
              onChange={(updated) => {
                const newConditions = [...rules.conditions]
                newConditions[index] = updated
                setRules({ ...rules, conditions: newConditions })
              }}
              onRemove={() => {
                const newConditions = rules.conditions.filter((_, i) => i !== index)
                setRules({ ...rules, conditions: newConditions })
              }}
            />
          ))}
        </div>

        <Button
          variant="outline"
          size="sm"
          className="mt-2"
          onClick={() => {
            setRules({
              ...rules,
              conditions: [
                ...rules.conditions,
                { field: 'tags', operator: 'contains', value: '' }
              ]
            })
          }}
        >
          <Plus className="mr-2 h-4 w-4" />
          Add Condition
        </Button>
      </div>

      <Button onClick={() => onSave(rules)}>
        Create Segment
      </Button>
    </div>
  )
}
```

---

## 🗄️ Complete Database Schema (v5.0)

### Core Tables (from v4.0, unchanged)
- `leads` - Customer contacts
- `messages` - Conversation history
- `conversation_state` - LangGraph state persistence
- `campaigns` - WhatsApp/Instagram campaigns
- `campaign_messages` - Campaign DMs
- `stock_alerts` - Stock notification queue
- `knowledge_base` - RAG documents
- `knowledge_base_embeddings` - PGVector embeddings

### NEW Tables (v5.0)
- `tenants` - Multi-tenant isolation (**P0 requirement**)
- `analytics_events` - Event tracking for analytics dashboard
- `research_tasks` - Multi-agent research jobs
- `research_agent_logs` - Research agent activity logs
- `email_campaigns` - Email marketing campaigns
- `email_campaign_recipients` - Email recipients + tracking
- `forms` - Form/quiz definitions
- `form_submissions` - Form responses
- `segments` - CRM segments
- `segment_memberships` - Contact-segment relationships

### Multi-Tenant Isolation (P0 Fix)

```sql
-- NEW: Tenants table
CREATE TABLE tenants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,

    -- Chatwoot mapping
    chatwoot_account_id VARCHAR(50) UNIQUE NOT NULL,
    chatwoot_api_token TEXT NOT NULL,

    -- Supabase isolation
    supabase_schema VARCHAR(50),  -- If using schema-per-tenant

    -- Status
    status VARCHAR(50) DEFAULT 'active',
    tier VARCHAR(50) DEFAULT 'standard',  -- "free", "standard", "premium"

    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add tenant_id to ALL existing tables:
ALTER TABLE leads ADD COLUMN tenant_id UUID NOT NULL REFERENCES tenants(id);
ALTER TABLE messages ADD COLUMN tenant_id UUID NOT NULL REFERENCES tenants(id);
ALTER TABLE campaigns ADD COLUMN tenant_id UUID NOT NULL REFERENCES tenants(id);
ALTER TABLE campaign_messages ADD COLUMN tenant_id UUID NOT NULL REFERENCES tenants(id);
ALTER TABLE stock_alerts ADD COLUMN tenant_id UUID NOT NULL REFERENCES tenants(id);
ALTER TABLE conversation_state ADD COLUMN tenant_id UUID NOT NULL REFERENCES tenants(id);
ALTER TABLE knowledge_base ADD COLUMN tenant_id UUID NOT NULL REFERENCES tenants(id);
ALTER TABLE analytics_events ADD COLUMN tenant_id UUID NOT NULL REFERENCES tenants(id);
ALTER TABLE research_tasks ADD COLUMN tenant_id UUID NOT NULL REFERENCES tenants(id);
ALTER TABLE email_campaigns ADD COLUMN tenant_id UUID NOT NULL REFERENCES tenants(id);
ALTER TABLE forms ADD COLUMN tenant_id UUID NOT NULL REFERENCES tenants(id);
ALTER TABLE segments ADD COLUMN tenant_id UUID NOT NULL REFERENCES tenants(id);

-- Enable RLS on ALL tables:
ALTER TABLE leads ENABLE ROW LEVEL SECURITY;
ALTER TABLE messages ENABLE ROW LEVEL SECURITY;
-- (repeat for all tables)

-- Create RLS policies:
CREATE POLICY tenant_isolation_leads ON leads
    USING (tenant_id = current_setting('app.current_tenant', true)::uuid);

CREATE POLICY tenant_isolation_messages ON messages
    USING (tenant_id = current_setting('app.current_tenant', true)::uuid);

-- (repeat for all tables)

-- Usage in application:
-- Set tenant context at request start:
await supabase.rpc('set_current_tenant', { tenant_id: 'uuid-here' })

-- All subsequent queries automatically scoped to tenant:
SELECT * FROM leads  -- Only returns leads for current tenant
```

### Optimistic Locking (P0 Fix)

```sql
-- Add version column to tables with dual UI writes:
ALTER TABLE leads ADD COLUMN version INTEGER DEFAULT 1;
ALTER TABLE segments ADD COLUMN version INTEGER DEFAULT 1;
ALTER TABLE forms ADD COLUMN version INTEGER DEFAULT 1;

-- Update logic with optimistic locking:
UPDATE leads
SET
    qualification_status = 'qualified',
    tags = ARRAY['VIP', 'Urgent'],
    version = version + 1,
    updated_at = NOW()
WHERE id = '...'
  AND version = 5;  -- Expected version

-- If affected_rows = 0, version conflict detected
-- → Re-fetch current data
-- → Retry update with new version
```

---

## 🚀 Deployment Architecture (14 Weeks)

### Infrastructure Stack

**Production Deployment**:
- **Backend (FastAPI + LangGraph)**: Railway ($20-40/month per client)
- **Next.js Dashboard**: Vercel ($20/month)
- **Chatwoot**: Railway Docker container ($25/month)
- **Chatwoot PostgreSQL**: Railway ($15/month)
- **Redis**: Railway ($10/month)
- **Supabase**: Pro tier ($25/month) for production workloads
- **360Dialog**: $45-150/month (WhatsApp)
- **Resend**: $20/month (50K emails)

**Total Infrastructure**: $175-250/month per client

### Monitoring & Observability (P0 Fix)

```yaml
# docker-compose-monitoring.yml
services:
  # Jaeger (Distributed Tracing)
  jaeger:
    image: jaegertracing/all-in-one:latest
    ports:
      - "16686:16686"  # UI
      - "14268:14268"  # Collector
    environment:
      - COLLECTOR_OTLP_ENABLED=true

  # Prometheus (Metrics)
  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml

  # Grafana (Dashboards)
  grafana:
    image: grafana/grafana:latest
    ports:
      - "3001:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - ./grafana/dashboards:/etc/grafana/provisioning/dashboards
```

**OpenTelemetry Integration**:
```python
# agent/telemetry.py
from opentelemetry import trace
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor
from opentelemetry.exporter.jaeger.thrift import JaegerExporter

# Setup tracer
trace.set_tracer_provider(TracerProvider())
jaeger_exporter = JaegerExporter(
    agent_host_name="jaeger",
    agent_port=6831,
)
trace.get_tracer_provider().add_span_processor(
    BatchSpanProcessor(jaeger_exporter)
)

tracer = trace.get_tracer(__name__)

# Usage in webhook:
@app.post("/webhooks/chatwoot")
async def chatwoot_webhook(event: dict):
    trace_id = event.get("id", "unknown")

    with tracer.start_as_current_span(
        "chatwoot_webhook",
        attributes={
            "message_id": trace_id,
            "channel": event.get("inbox", {}).get("channel_type"),
            "customer_id": event.get("sender", {}).get("id")
        }
    ):
        # Process webhook
        result = await langgraph_workflow.ainvoke(event)

        return {"status": "ok", "trace_id": trace_id}
```

---

## 💰 Cost Analysis v5.0

### Per-Client Monthly Costs

| Component | Cost | Notes |
|-----------|------|-------|
| **Infrastructure** |
| Railway (FastAPI + Celery) | $40 | 2GB RAM + background jobs |
| Vercel (Next.js) | $20 | Pro tier for team features |
| Chatwoot (Railway) | $25 | 4GB RAM Docker |
| Chatwoot PostgreSQL | $15 | 2GB RAM |
| Redis | $10 | 1GB RAM |
| Supabase Pro | $25 | Connection pooler + increased limits |
| **Channels** |
| 360Dialog (WhatsApp) | $45-150 | Based on message volume |
| Meta Graph API (Instagram) | $0 | Free |
| Resend (Email) | $20 | 50K emails/month |
| **TOTAL** | **$200-325/month** | Per client |

### AI Costs (Variable)

| Use Case | Model | Cost per Use | Monthly @ 500 uses |
|----------|-------|--------------|---------------------|
| Conversation (Agent 2) | Claude 3.5 Sonnet | $0.15/conv (10 msgs) | $75 |
| Campaign DM (Agent 3) | Claude 3.5 Sonnet | $0.10/DM | $50 |
| Email Generation (Agent 6) | Claude 3.5 Sonnet | $0.08/email | $40 |
| Research Task (Agent 5) | Claude 3.5 (3 agents) | $0.50/task | $250 (if 500 tasks) |
| Router (all messages) | GPT-4o-mini | $0.001/msg | $0.50 |
| Extraction (Agent 1) | GPT-4o-mini | $0.003/extract | $1.50 |
| CRM Ops (Agent 4) | GPT-4o-mini | $0.001/op | $0.50 |
| Form Processing (Agent 7) | GPT-4o-mini | $0.002/submission | $1.00 |
| **TOTAL AI** | | | **~$418/month** |

**Total Monthly Cost per Client**: $618-743 (infrastructure + AI)

### Pricing Strategy

**Recommended SaaS Pricing**:
- **Standard Plan**: $2,000/month (covers costs + 60% margin)
- **Premium Plan**: $3,500/month (unlimited research, priority support)
- **Enterprise Plan**: Custom pricing ($5K+/month for white-label)

**ROI at Scale**:
- **10 clients**: $20K MRR - $7.4K costs = **$12.6K profit/month**
- **50 clients**: $100K MRR - $37K costs = **$63K profit/month**

---

## 📅 Implementation Roadmap (14 Weeks)

### Phase 1: Foundation (Weeks 1-2)

**Week 1: Database & Multi-Tenancy**
- [ ] Create `tenants` table
- [ ] Add `tenant_id` to all existing tables
- [ ] Implement RLS policies for all tables
- [ ] Add `version` column for optimistic locking
- [ ] Create database migration scripts
- [ ] Test multi-tenant isolation

**Week 2: Dual UI Setup**
- [ ] Deploy Chatwoot Docker container
- [ ] Configure Chatwoot multi-channel inboxes
- [ ] Setup Next.js project (App Router + TypeScript)
- [ ] Integrate Supabase client (both UIs)
- [ ] Implement webhook signature verification
- [ ] Test Chatwoot → FastAPI webhook flow

### Phase 2: Core Integration (Weeks 3-5)

**Week 3: LangGraph Enhancement**
- [ ] Update `ConversationState` for v5.0 (new fields)
- [ ] Enhance Router Agent (detect new intents)
- [ ] Test existing agents (1, 2, 3, 4) still work
- [ ] Implement distributed tracing (OpenTelemetry)
- [ ] Deploy Jaeger + Grafana
- [ ] Test end-to-end tracing

**Week 4: Analytics Dashboard**
- [ ] Create `analytics_events` table
- [ ] Build Analytics page in Next.js
- [ ] Implement real-time metrics (Supabase subscriptions)
- [ ] Create charts (conversations, campaigns, agents)
- [ ] Test real-time updates
- [ ] Add export functionality (CSV)

**Week 5: Multi-Agent Research**
- [ ] Build Agent 5 (Research Orchestrator)
- [ ] Implement web search tool (Serper API)
- [ ] Implement web scrape tool (Playwright/Puppeteer)
- [ ] Create `research_tasks` + `research_agent_logs` tables
- [ ] Build Research page in Next.js
- [ ] Test parallel agent execution

### Phase 3: Marketing Automation (Weeks 6-8)

**Week 6: Resend Email Marketing**
- [ ] Build Agent 6 (Email Marketing)
- [ ] Integrate Resend API
- [ ] Create `email_campaigns` + `email_campaign_recipients` tables
- [ ] Implement Resend webhook handler
- [ ] Build Email Marketing page in Next.js
- [ ] Test email sending + tracking

**Week 7: Form/Quiz Builder**
- [ ] Build Agent 7 (Form Processing)
- [ ] Create `forms` + `form_submissions` tables
- [ ] Build drag-drop form builder UI
- [ ] Implement form rendering (public page)
- [ ] Test AI auto-tagging
- [ ] Test CRM sync

**Week 8: Advanced CRM Segmentation**
- [ ] Create `segments` + `segment_memberships` tables
- [ ] Implement segment rule engine
- [ ] Build Segments page in Next.js
- [ ] Test dynamic segment updates
- [ ] Test segment-based campaign targeting

### Phase 4: Integration & Polish (Weeks 9-10)

**Week 9: Dual UI Synchronization**
- [ ] Implement optimistic locking (handle conflicts)
- [ ] Test Chatwoot tag → Supabase → Next.js sync
- [ ] Test Next.js campaign → Chatwoot inbox sync
- [ ] Implement polling for campaign status
- [ ] Test webhook reliability (retry logic)
- [ ] Stress test (100+ concurrent updates)

**Week 10: Dashboard UX Enhancement**
- [ ] Embed Chatwoot iframe in Next.js (optional)
- [ ] Align design systems (colors, fonts)
- [ ] Implement shared component library
- [ ] Add navigation between UIs
- [ ] Test mobile responsiveness
- [ ] User acceptance testing (UAT)

### Phase 5: Testing & Hardening (Weeks 11-12)

**Week 11: Security & Performance**
- [ ] Security audit (RLS policies, webhook signatures)
- [ ] Load testing (Locust/k6)
- [ ] Connection pool optimization
- [ ] API rate limiting (per-source)
- [ ] Circuit breaker implementation
- [ ] Webhook idempotency

**Week 12: End-to-End Testing**
- [ ] Test all 9 use cases manually
- [ ] Automated E2E tests (Playwright)
- [ ] Test multi-tenant isolation
- [ ] Test all agent workflows
- [ ] Fix critical bugs (P0/P1 only)
- [ ] Performance optimization

### Phase 6: Deployment & Launch (Weeks 13-14)

**Week 13: Staging Deployment**
- [ ] Deploy to Railway staging environment
- [ ] Configure Chatwoot production settings
- [ ] Setup Resend production account
- [ ] Configure 360Dialog webhooks
- [ ] End-to-end smoke tests
- [ ] Documentation (API docs, user guides)

**Week 14: Production Launch**
- [ ] Deploy to Railway production
- [ ] Monitor for errors (first 48 hours)
- [ ] Customer onboarding (first client)
- [ ] Gather feedback
- [ ] Fix any critical issues
- [ ] Plan v5.1 enhancements

---

## ✅ Success Criteria

### Technical Metrics
- [ ] 99% uptime (max 7 hours downtime/month)
- [ ] <3 seconds average response time (webhook → agent response)
- [ ] <5% error rate across all workflows
- [ ] Zero cross-tenant data leaks (security audit passed)
- [ ] All 9 use cases functional in production

### Business Metrics
- [ ] 75%+ conversations auto-handled by agents
- [ ] Campaign conversion rate >12% (WhatsApp/Instagram)
- [ ] Email open rate >25%, click rate >5%
- [ ] Research tasks complete in <5 minutes (avg)
- [ ] Form submissions sync to CRM within 10 seconds

### User Experience Metrics
- [ ] Operations team can takeover any conversation in <30 seconds
- [ ] Marketing team can launch campaign in <10 minutes
- [ ] Analytics dashboard loads in <2 seconds
- [ ] Zero user-reported bugs in first 30 days (P0/P1)
- [ ] Customer satisfaction score (CSAT) >4.5/5.0

---

## 🔮 Future Enhancements (v5.1+)

### Planned Features
1. **Voice AI** (Phone calls via Twilio/Vapi)
2. **Advanced RAG** (Multi-modal embeddings, PDF uploads)
3. **A/B Testing** (Campaign variants, email subject lines)
4. **Predictive Analytics** (Lead scoring, churn prediction)
5. **Workflow Automation** (Zapier-style visual builder)
6. **Mobile App** (React Native for operations team)
7. **WhiteLabel** (Custom branding per client)
8. **API Marketplace** (Public API for developers)

### Technical Debt to Address
- [ ] Migrate from Docker Compose to Kubernetes (scale > 100 clients)
- [ ] Implement caching layer (Redis caching for Supabase queries)
- [ ] Database sharding (separate DB per 50 clients)
- [ ] Message queue (RabbitMQ/Kafka instead of Celery/Redis)
- [ ] CI/CD pipeline (automated testing + deployment)

---

## 📝 Appendices

### A. Glossary
- **Dual UI**: Two separate user interfaces (Chatwoot + Next.js) sharing same database
- **RLS**: Row-Level Security (Supabase feature for multi-tenant data isolation)
- **Optimistic Locking**: Concurrency control using version numbers to prevent lost updates
- **Webhook**: HTTP callback triggered by external service (e.g., Chatwoot notifies us)
- **LangGraph**: Framework for building multi-agent workflows as state machines
- **PGVector**: PostgreSQL extension for vector embeddings (RAG/semantic search)

### B. Reference Documentation
- LangGraph: https://langchain-ai.github.io/langgraph/
- Chatwoot: https://www.chatwoot.com/docs/
- Supabase: https://supabase.com/docs
- Resend: https://resend.com/docs
- Next.js 14: https://nextjs.org/docs
- OpenTelemetry: https://opentelemetry.io/docs/

### C. Team Contacts
- **Tech Lead**: [Name] - Architecture decisions
- **Backend Developer**: [Name] - FastAPI + LangGraph
- **Frontend Developer**: [Name] - Next.js + Chatwoot
- **DevOps Engineer**: [Name] - Railway + monitoring
- **Product Manager**: [Name] - Requirements + prioritization

---

**END OF PRD V5.0**

**Total Pages**: 100+
**Generated By**: SDK AGENTS Complete Workflow
**Validation**: EVP Score 7.2/10 - APPROVED WITH CONDITIONS
**Next Steps**: Begin Phase 1 implementation (Week 1: Multi-Tenancy)

---

**IMPORTANT NOTES FOR IMPLEMENTATION**:

1. **P0 Fixes MUST Be Addressed in Week 1**:
   - Multi-tenant isolation (`tenant_id` + RLS)
   - Optimistic locking (`version` column)
   - Distributed tracing (OpenTelemetry + Jaeger)

2. **Dual UI Complexity Warning**:
   - Requires 16 hours/month maintenance (vs 10 hours for single UI)
   - Dual UI adds 30% infrastructure cost
   - Only justified for clients with 5+ operations team members

3. **Cost Justification for $2,000+/month Pricing**:
   - Custom AI agents (not locked like Intercom/Zendesk)
   - Self-hosted (data ownership + GDPR compliance)
   - Multi-channel (WhatsApp + Instagram + Email + SMS)
   - Advanced features (research, forms, segmentation)
   - 70% cheaper than enterprise alternatives at scale

4. **Timeline Realism**:
   - 14 weeks is achievable for CORE features
   - Advanced features (voice AI, A/B testing) deferred to v5.1
   - 2-week testing buffer is critical (don't skip!)

5. **Deployment Strategy**:
   - Start with 1 pilot client (beauty salon)
   - Gather feedback for 30 days
   - Iterate based on real usage
   - Then onboard 10 clients (Month 6 target)