# 📋 Multi-Channel AI Engagement Platform - PRD v4.0

**Generated by SDK AGENTS Complete Workflow**
**Date**: January 2025
**Version**: 4.0 (LangGraph + Chatwoot Multi-Channel System)
**Status**: ✅ ARCHITECTURE UPGRADE - Enterprise Multi-Agent Orchestration

---

## 🎯 Executive Summary

### What Changed from v3.0

**v3.0** → Simple 2-agent system (WhatsApp only)
**v4.0** → **LangGraph orchestrated multi-agent system** with **Chatwoot multi-channel inbox**

### Why This Upgrade?

**PROBLEM SOLVED:**
1. ✅ **Multiple channels**: Not just WhatsApp - Instagram, Email, SMS, Telegram
2. ✅ **Priority routing**: AI determines which messages need human attention
3. ✅ **Proactive campaigns**: AI-driven outbound messaging
4. ✅ **CRM automation**: Stock alerts, follow-ups, notifications
5. ✅ **Human-in-the-loop**: Built-in live chat takeover via Chatwoot
6. ✅ **Stateful workflows**: Complex flows that span multiple days/interactions

### New Capabilities

| Feature | v3.0 | v4.0 |
|---------|------|------|
| **Channels** | WhatsApp only | WhatsApp, Instagram, Email, SMS, Telegram, Chat |
| **Orchestration** | Simple if/else | LangGraph state machine |
| **Dashboard** | Custom built | Chatwoot embedded + custom widgets |
| **Agent Type** | 2 agents | Multi-agent swarm with routing |
| **Workflows** | Linear | Complex stateful workflows |
| **Campaigns** | Manual | Automated DM campaigns |
| **CRM** | Basic | Full CRM with tags, notes, alerts |
| **Human Takeover** | Not built | Native Chatwoot feature |

---

## 🏗️ New Technical Architecture

### System Overview

```
┌─────────────────────────────────────────────────────────┐
│          MULTI-CHANNEL COMMUNICATION LAYER              │
│  WhatsApp · Instagram DM · Email · SMS · Telegram      │
└────────────────────┬────────────────────────────────────┘
                     ↓
         ┌───────────────────────┐
         │   CHATWOOT INBOX      │
         │   (Unified Interface) │
         │   - Contact mgmt      │
         │   - Conversation UI   │
         │   - Team assignments  │
         │   - Labels & tags     │
         └──────────┬────────────┘
                    ↓ Webhook
         ┌─────────────────────────────────┐
         │   FASTAPI WEBHOOK RECEIVER      │
         │   POST /webhooks/chatwoot       │
         │   (Returns 200 OK < 1 sec)      │
         └──────────┬──────────────────────┘
                    ↓
         ┌─────────────────────────────────┐
         │   LANGGRAPH ORCHESTRATOR 🧠      │
         │   (State Machine + Router)      │
         │                                 │
         │   STATE: {                      │
         │     channel: "instagram",       │
         │     intent: "product_inquiry",  │
         │     priority: "high",           │
         │     needs_human: false,         │
         │     conversation_history: [...] │
         │   }                             │
         └──────────┬──────────────────────┘
                    ↓
      ┌─────────────┴─────────────┐
      │                           │
      ↓                           ↓
┌─────────────┐         ┌─────────────────┐
│  ROUTER     │         │  AGENT SWARM    │
│  AGENT      │  ───→   │                 │
│             │         │ • Agent 1       │
│ Classifies: │         │   (Extraction)  │
│ • Priority  │         │                 │
│ • Intent    │         │ • Agent 2       │
│ • Route     │         │   (Conversation)│
└─────────────┘         │                 │
                        │ • Agent 3       │
                        │   (Campaign)    │
                        │                 │
                        │ • Agent 4       │
                        │   (CRM)         │
                        └─────────────────┘
                                ↓
                    ┌───────────────────────┐
                    │  DECISION NODES       │
                    │                       │
                    │  • Can agent handle?  │
                    │  • Escalate to human? │
                    │  • Create follow-up?  │
                    │  • Trigger campaign?  │
                    └───────────┬───────────┘
                                ↓
                    ┌───────────────────────┐
                    │  ACTION LAYER         │
                    │                       │
                    │  • Reply via Chatwoot │
                    │  • Update CRM         │
                    │  • Create alert       │
                    │  • Schedule follow-up │
                    └───────────────────────┘
```

---

## 🤖 Agent Architecture

### LangGraph State Machine

```python
class ConversationState(TypedDict):
    """State tracked throughout conversation"""
    # Message context
    message_id: str
    conversation_id: str
    customer_id: str
    channel: Literal["whatsapp", "instagram", "email", "sms"]
    message_content: str
    message_type: Literal["incoming", "outgoing"]

    # AI analysis
    intent: str  # "product_inquiry", "complaint", "stock_alert", etc.
    priority: Literal["high", "medium", "low"]
    sentiment: float  # -1.0 to 1.0

    # Routing decisions
    route: str  # "agent", "human", "automated"
    needs_human: bool
    escalation_reason: Optional[str]

    # Agent responses
    agent_response: Optional[str]
    tools_used: List[str]

    # CRM data
    customer_profile: Dict
    conversation_history: List[Dict]
    tags: List[str]
    follow_up_needed: bool
    follow_up_date: Optional[datetime]

    # Campaign context
    is_campaign_message: bool
    campaign_id: Optional[str]

    # Stock alert context
    product_interest: Optional[str]
    stock_alert_requested: bool
```

### Agent Roles

#### **Router Agent** (LangGraph Entry Point)
```python
def router_agent(state: ConversationState) -> str:
    """
    Classifies incoming message and routes to appropriate handler

    Returns:
    - "handle_high_priority" → Immediate human notification
    - "handle_agent" → Standard agent processing
    - "handle_automated" → Fully automated (FAQ, simple queries)
    - "handle_campaign" → Campaign-related interaction
    - "handle_stock_alert" → Stock alert workflow
    """
```

**Responsibilities:**
- ✅ Priority classification (high/medium/low)
- ✅ Intent detection (product_inquiry, complaint, stock_alert, etc.)
- ✅ Sentiment analysis
- ✅ Routing decision

**Model**: GPT-4o-mini (fast + cheap)
**Cost**: ~$0.001 per classification

---

#### **Agent 1: Extraction Agent** (Pydantic AI)
```python
class LeadQualification(BaseModel):
    """Structured extraction from conversation"""
    full_name: Optional[str]
    email: Optional[str]
    phone: Optional[str]

    # Context
    product_interest: Optional[str]
    budget_mentioned: Optional[float]
    urgency: Literal["high", "medium", "low"]

    # Qualification scores
    engagement_score: int  # 0-100
    intent_score: int  # 0-100
    fit_score: int  # 0-100

    # CRM actions
    should_tag: List[str]
    should_notify_human: bool
    follow_up_recommended: bool
```

**Responsibilities:**
- ✅ Extract structured data from freeform conversation
- ✅ Calculate qualification scores
- ✅ Detect missing information
- ✅ Recommend CRM tags

**Model**: GPT-4o-mini
**Triggers**: Every 5 messages OR when agent detects qualification opportunity
**Cost**: ~$0.003 per extraction

---

#### **Agent 2: Conversation Agent** (Claude SDK)
```python
class ConversationAgent:
    """Natural language conversation with tool use"""

    tools = [
        "search_products",     # RAG search in product catalog
        "search_knowledge",    # RAG search in knowledge base
        "check_stock",         # Check product availability
        "book_appointment",    # Calendar integration
        "create_stock_alert",  # CRM automation
    ]
```

**Responsibilities:**
- ✅ Natural conversation in user's language
- ✅ Answer product questions (via RAG)
- ✅ Tool use for real-time info
- ✅ Context retention across messages

**Model**: Claude 3.5 Sonnet
**Triggers**: EVERY incoming message
**Cost**: ~$0.15 per conversation (10 messages)

---

#### **Agent 3: Campaign Agent** (NEW!)
```python
class CampaignAgent:
    """Proactive outbound messaging"""

    async def analyze_product(self, product_url: str) -> ProductAnalysis:
        """Analyze product for campaign"""

    async def generate_personalized_dm(
        self,
        product: ProductAnalysis,
        target_customer: Customer
    ) -> str:
        """Generate DM based on customer profile"""

    async def monitor_campaign(self, campaign_id: str):
        """Track responses and engagement"""
```

**Responsibilities:**
- ✅ Analyze products for DM campaigns
- ✅ Generate personalized messages
- ✅ Monitor campaign performance
- ✅ Decide when to escalate to human

**Model**: Claude 3.5 Sonnet
**Triggers**: Manual campaign launch
**Cost**: ~$0.10 per DM generated

---

#### **Agent 4: CRM Agent** (NEW!)
```python
class CRMAgent:
    """Automates CRM workflows"""

    async def create_stock_alert(
        self,
        customer: Customer,
        product: str,
        conversation_context: str
    ):
        """Create stock alert with full context"""

    async def process_stock_return(self, product: str):
        """Notify all customers waiting for stock"""

    async def schedule_follow_up(
        self,
        customer: Customer,
        follow_up_date: datetime,
        reason: str
    ):
        """Schedule future action"""
```

**Responsibilities:**
- ✅ Stock alert management
- ✅ Automated follow-ups
- ✅ CRM tagging and notes
- ✅ Customer segmentation

**Model**: GPT-4o-mini (simple operations)
**Triggers**: Agent decisions or manual actions
**Cost**: ~$0.001 per CRM operation

---

## 🔄 LangGraph Workflows

### Workflow 1: Incoming Message Processing

```python
workflow = StateGraph(ConversationState)

# Nodes
workflow.add_node("classify", router_agent)
workflow.add_node("extract_lead_info", agent1_extraction)
workflow.add_node("generate_response", agent2_conversation)
workflow.add_node("check_escalation", check_needs_human)
workflow.add_node("notify_human", send_human_notification)
workflow.add_node("update_crm", update_chatwoot_crm)
workflow.add_node("send_response", send_via_chatwoot)

# Conditional edges
workflow.add_conditional_edges(
    "classify",
    route_based_on_priority,
    {
        "high_priority": "notify_human",
        "standard": "generate_response",
        "automated": "send_response"
    }
)

workflow.add_conditional_edges(
    "check_escalation",
    should_escalate,
    {
        "escalate": "notify_human",
        "continue": "send_response"
    }
)

# Entry point
workflow.set_entry_point("classify")
```

**Flow:**
1. Message comes in → Router classifies
2. High priority → Immediate human notification + agent still responds
3. Standard → Agent processes → Check if escalation needed
4. Automated → Direct response (FAQ, simple queries)
5. All paths → Update CRM + send response

---

### Workflow 2: Product DM Campaign

```python
campaign_workflow = StateGraph(CampaignState)

# Nodes
campaign_workflow.add_node("analyze_product", agent3_analyze)
campaign_workflow.add_node("select_targets", select_customers)
campaign_workflow.add_node("generate_dms", agent3_generate_dms)
campaign_workflow.add_node("send_dms", send_via_chatwoot)
campaign_workflow.add_node("monitor_responses", monitor_engagement)
campaign_workflow.add_node("handle_response", agent2_conversation)
campaign_workflow.add_node("escalate_if_needed", check_escalation)

# Conditional edges
campaign_workflow.add_conditional_edges(
    "monitor_responses",
    check_response_status,
    {
        "response_received": "handle_response",
        "no_response": END,
        "question_asked": "handle_response"
    }
)

campaign_workflow.add_conditional_edges(
    "handle_response",
    can_agent_handle,
    {
        "agent_handles": "send_dms",
        "needs_human": "escalate_if_needed"
    }
)
```

**Flow:**
1. User provides product URL + target audience
2. Agent 3 analyzes product (features, benefits, USPs)
3. Select target customers from CRM
4. Generate personalized DM for each
5. Send via Chatwoot (Instagram/WhatsApp)
6. Monitor responses
7. Agent answers questions OR escalate to human
8. Track conversions

---

### Workflow 3: Stock Alert System

```python
stock_alert_workflow = StateGraph(StockAlertState)

# Nodes
stock_alert_workflow.add_node("detect_stock_request", router_agent)
stock_alert_workflow.add_node("extract_product", agent1_extraction)
stock_alert_workflow.add_node("create_crm_entry", agent4_crm)
stock_alert_workflow.add_node("tag_customer", update_chatwoot_tags)
stock_alert_workflow.add_node("confirm_alert", send_confirmation)

# Background job workflow
stock_alert_workflow.add_node("check_stock", check_product_stock)
stock_alert_workflow.add_node("notify_customers", agent4_notify)
stock_alert_workflow.add_node("update_status", mark_as_notified)

# Conditional edges
stock_alert_workflow.add_conditional_edges(
    "check_stock",
    is_product_available,
    {
        "in_stock": "notify_customers",
        "out_of_stock": END
    }
)
```

**Flow:**
1. Customer asks: "Let me know when this is back in stock"
2. Router detects `intent = "stock_alert"`
3. Agent 1 extracts product name/details
4. Agent 4 creates CRM entry with:
   - Product requested
   - Full conversation context
   - Customer contact info
   - Channel (for later notification)
5. Update Chatwoot contact:
   - Tag: "STOCK_ALERT", "IMPORTANT"
   - Custom attribute: `waiting_for = "product_name"`
6. Agent 2 confirms: "I'll message you as soon as it's available!"
7. **Background job** (Celery) checks stock hourly
8. When in stock:
   - Agent 4 notifies ALL waiting customers
   - Personalized message per customer
   - Sent via original channel
   - CRM updated: `status = "notified"`

---

## 🌐 Chatwoot Integration

### Why Chatwoot?

**REPLACES:**
- ❌ Custom dashboard we were building
- ❌ Custom chat UI
- ❌ Manual CRM implementation
- ❌ Channel-specific integrations

**PROVIDES:**
- ✅ Multi-channel inbox (WhatsApp, Instagram, Email, SMS, Telegram, Live Chat)
- ✅ Team collaboration (assignments, internal notes, mentions)
- ✅ CRM features (contacts, labels, custom attributes)
- ✅ Conversation history
- ✅ Canned responses (templates)
- ✅ Automation rules
- ✅ Reports & analytics
- ✅ Human takeover (built-in live chat)
- ✅ REST API + Webhooks
- ✅ Open source (full customization)

### Architecture

```
┌─────────────────────────────────────────┐
│          CHATWOOT SELF-HOSTED           │
│         (Docker Container)              │
│                                         │
│  ┌───────────────────────────────────┐ │
│  │  Multi-Channel Inboxes            │ │
│  │  ├─ WhatsApp (360Dialog)          │ │
│  │  ├─ Instagram (Meta Business)     │ │
│  │  ├─ Email (SMTP)                  │ │
│  │  ├─ SMS (Twilio)                  │ │
│  │  └─ Telegram                      │ │
│  └───────────────────────────────────┘ │
│                                         │
│  ┌───────────────────────────────────┐ │
│  │  Contact CRM                      │ │
│  │  • Custom attributes              │ │
│  │  • Labels & tags                  │ │
│  │  • Notes & history                │ │
│  │  • Team assignments               │ │
│  └───────────────────────────────────┘ │
│                                         │
│  ┌───────────────────────────────────┐ │
│  │  Webhooks                         │ │
│  │  → message_created                │ │
│  │  → message_updated                │ │
│  │  → conversation_status_changed    │ │
│  └───────────────────────────────────┘ │
└─────────────┬───────────────────────────┘
              ↓
    ┌─────────────────────┐
    │  Our FastAPI        │
    │  Webhook Handler    │
    └─────────────────────┘
              ↓
    ┌─────────────────────┐
    │  LangGraph          │
    │  Orchestrator       │
    └─────────────────────┘
```

### Webhook Integration

```python
@app.post("/webhooks/chatwoot")
async def chatwoot_webhook(event: dict):
    """
    Handle Chatwoot webhook events

    Events:
    - message_created: New message from customer
    - message_updated: Message edited
    - conversation_status_changed: Status changed (open/resolved)
    """

    if event["event"] == "message_created":
        # Only process incoming messages (not our own responses)
        if event["message_type"] == "incoming":

            # Initialize LangGraph state
            initial_state = {
                "message_id": event["id"],
                "conversation_id": event["conversation"]["id"],
                "customer_id": event["sender"]["id"],
                "channel": event["inbox"]["channel_type"],
                "message_content": event["content"],
                "message_type": "incoming",
            }

            # Run LangGraph workflow
            result = await conversation_workflow.ainvoke(initial_state)

            # Response is sent within workflow (via Chatwoot API)

    return {"status": "ok"}
```

### Chatwoot API Client

```python
class ChatwootAPI:
    def __init__(self, base_url: str, api_token: str, account_id: str):
        self.base_url = base_url
        self.headers = {
            "api_access_token": api_token,
            "Content-Type": "application/json"
        }
        self.account_id = account_id

    async def send_message(
        self,
        conversation_id: int,
        message: str,
        message_type: str = "outgoing"
    ):
        """Send message via Chatwoot"""
        url = f"{self.base_url}/api/v1/accounts/{self.account_id}/conversations/{conversation_id}/messages"

        payload = {
            "content": message,
            "message_type": message_type  # "outgoing" = from agent
        }

        async with httpx.AsyncClient() as client:
            response = await client.post(url, json=payload, headers=self.headers)
            return response.json()

    async def add_contact_labels(
        self,
        contact_id: int,
        labels: List[str]
    ):
        """Tag customer in CRM"""
        url = f"{self.base_url}/api/v1/accounts/{self.account_id}/contacts/{contact_id}"

        payload = {"labels": labels}

        async with httpx.AsyncClient() as client:
            response = await client.put(url, json=payload, headers=self.headers)
            return response.json()

    async def update_contact_attributes(
        self,
        contact_id: int,
        custom_attributes: dict
    ):
        """Update CRM custom fields"""
        url = f"{self.base_url}/api/v1/accounts/{self.account_id}/contacts/{contact_id}"

        payload = {"custom_attributes": custom_attributes}

        async with httpx.AsyncClient() as client:
            response = await client.put(url, json=payload, headers=self.headers)
            return response.json()

    async def create_note(
        self,
        conversation_id: int,
        note: str
    ):
        """Add internal note (not visible to customer)"""
        url = f"{self.base_url}/api/v1/accounts/{self.account_id}/conversations/{conversation_id}/messages"

        payload = {
            "content": note,
            "message_type": "outgoing",
            "private": True  # Internal note
        }

        async with httpx.AsyncClient() as client:
            response = await client.post(url, json=payload, headers=self.headers)
            return response.json()
```

---

## 🗄️ Database Schema Updates

### New Tables for v4.0

#### `campaigns` table
```sql
CREATE TABLE campaigns (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    product_name VARCHAR(255),
    product_url TEXT,
    product_description TEXT,
    target_channel VARCHAR(50), -- "instagram", "whatsapp", "both"
    status VARCHAR(50) DEFAULT 'active', -- "active", "paused", "completed"

    -- Metrics
    sent_count INTEGER DEFAULT 0,
    response_count INTEGER DEFAULT 0,
    conversion_count INTEGER DEFAULT 0,

    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    launched_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,

    -- Metadata
    created_by VARCHAR(255),
    settings JSONB
);
```

#### `campaign_messages` table
```sql
CREATE TABLE campaign_messages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    campaign_id UUID REFERENCES campaigns(id) ON DELETE CASCADE,
    customer_id UUID REFERENCES leads(id),
    conversation_id VARCHAR(255), -- Chatwoot conversation ID

    -- Message content
    message_content TEXT NOT NULL,
    personalization_data JSONB,

    -- Status
    status VARCHAR(50) DEFAULT 'pending', -- "pending", "sent", "delivered", "read", "responded"
    sent_at TIMESTAMPTZ,
    delivered_at TIMESTAMPTZ,
    read_at TIMESTAMPTZ,
    responded_at TIMESTAMPTZ,

    -- Response tracking
    customer_responded BOOLEAN DEFAULT FALSE,
    response_content TEXT,
    needs_human_review BOOLEAN DEFAULT FALSE,

    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_campaign_messages_campaign ON campaign_messages(campaign_id);
CREATE INDEX idx_campaign_messages_customer ON campaign_messages(customer_id);
CREATE INDEX idx_campaign_messages_status ON campaign_messages(status);
```

#### `stock_alerts` table
```sql
CREATE TABLE stock_alerts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    customer_id UUID REFERENCES leads(id),
    conversation_id VARCHAR(255), -- Chatwoot conversation ID
    channel VARCHAR(50), -- "whatsapp", "instagram", etc.

    -- Product info
    product_name VARCHAR(255) NOT NULL,
    product_sku VARCHAR(100),
    product_url TEXT,

    -- Context
    conversation_context TEXT, -- Full chat history
    customer_message TEXT, -- Original message requesting alert

    -- Status
    status VARCHAR(50) DEFAULT 'pending', -- "pending", "notified", "expired"
    priority VARCHAR(20) DEFAULT 'high',

    -- Timestamps
    requested_at TIMESTAMPTZ DEFAULT NOW(),
    notified_at TIMESTAMPTZ,
    expires_at TIMESTAMPTZ, -- Optional expiry

    -- Metadata
    tags TEXT[],
    notes TEXT
);

CREATE INDEX idx_stock_alerts_customer ON stock_alerts(customer_id);
CREATE INDEX idx_stock_alerts_status ON stock_alerts(status);
CREATE INDEX idx_stock_alerts_product ON stock_alerts(product_name);
```

#### `conversation_state` table (for LangGraph persistence)
```sql
CREATE TABLE conversation_state (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    conversation_id VARCHAR(255) UNIQUE NOT NULL,

    -- State snapshot
    state JSONB NOT NULL,

    -- Metadata
    last_updated TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_conversation_state_conversation ON conversation_state(conversation_id);
```

---

## 📊 Dashboard Architecture

### Hybrid Approach: Chatwoot + Custom Widgets

```
┌─────────────────────────────────────────────────┐
│          MAIN DASHBOARD (Reflex)                │
│                                                 │
│  ┌───────────────┐  ┌───────────────────────┐  │
│  │  SIDEBAR      │  │  MAIN CONTENT AREA    │  │
│  │               │  │                       │  │
│  │  • Home       │  │  ┌─────────────────┐ │  │
│  │  • Inbox      │  │  │  CHATWOOT       │ │  │
│  │  • Campaigns  │  │  │  (iframe)       │ │  │
│  │  • Alerts     │  │  │                 │ │  │
│  │  • Analytics  │  │  │  • Live chat UI │ │  │
│  │  • Settings   │  │  │  • Contacts     │ │  │
│  └───────────────┘  │  │  • History      │ │  │
│                     │  └─────────────────┘ │  │
│                     │                       │  │
│                     │  CUSTOM WIDGETS       │  │
│                     │  ┌─────────────────┐ │  │
│                     │  │  Priority Queue │ │  │
│                     │  │  🔴 High: 3     │ │  │
│                     │  │  🟡 Med: 12     │ │  │
│                     │  │  🟢 Low: 45     │ │  │
│                     │  └─────────────────┘ │  │
│                     │                       │  │
│                     │  ┌─────────────────┐ │  │
│                     │  │  Active         │ │  │
│                     │  │  Campaigns      │ │  │
│                     │  │                 │ │  │
│                     │  │  • Product DM   │ │  │
│                     │  │    Sent: 45/100 │ │  │
│                     │  │    Conv: 12%    │ │  │
│                     │  └─────────────────┘ │  │
│                     └───────────────────────┘  │
└─────────────────────────────────────────────────┘
```

### Dashboard Pages

#### 1. **Inbox** (Chatwoot Embedded)
```python
def inbox_page() -> rx.Component:
    return rx.box(
        rx.heading("Unified Inbox"),

        # Chatwoot iframe
        rx.html(
            f"""
            <iframe
                src="{chatwoot_url}/app/accounts/{account_id}/inbox"
                width="100%"
                height="800px"
                style="border: none; border-radius: 8px;"
            />
            """
        )
    )
```

#### 2. **Campaigns** (Custom Page)
```python
def campaigns_page() -> rx.Component:
    return rx.vstack(
        rx.heading("Product DM Campaigns"),

        # Create new campaign
        rx.box(
            rx.heading("Launch New Campaign", size="6"),
            rx.form(
                rx.vstack(
                    rx.input(
                        placeholder="Campaign Name",
                        name="campaign_name"
                    ),
                    rx.input(
                        placeholder="Product URL",
                        name="product_url"
                    ),
                    rx.upload(
                        rx.text("Upload Product Images"),
                        name="product_images"
                    ),
                    rx.text_area(
                        placeholder="Product Description",
                        name="product_description"
                    ),
                    rx.number_input(
                        placeholder="How many people to target?",
                        name="target_count"
                    ),
                    rx.select(
                        ["Instagram DM", "WhatsApp", "Both"],
                        placeholder="Select Channel",
                        name="channel"
                    ),
                    rx.button(
                        "🚀 Launch Campaign",
                        on_click=DashboardState.launch_campaign
                    )
                )
            )
        ),

        # Active campaigns
        rx.box(
            rx.heading("Active Campaigns", size="6"),
            rx.foreach(
                DashboardState.active_campaigns,
                lambda campaign: campaign_card(campaign)
            )
        )
    )

def campaign_card(campaign: dict) -> rx.Component:
    return rx.box(
        rx.hstack(
            rx.vstack(
                rx.text(campaign["name"], weight="bold", size="5"),
                rx.text(f"Channel: {campaign['channel']}", size="2", color="gray")
            ),
            rx.spacer(),
            rx.badge(campaign["status"], color_scheme="blue")
        ),

        # Metrics
        rx.hstack(
            rx.vstack(
                rx.text(campaign["sent_count"], size="6", weight="bold"),
                rx.text("Sent", size="1", color="gray")
            ),
            rx.vstack(
                rx.text(campaign["response_count"], size="6", weight="bold"),
                rx.text("Responses", size="1", color="gray")
            ),
            rx.vstack(
                rx.text(f"{campaign['conversion_rate']}%", size="6", weight="bold"),
                rx.text("Conversions", size="1", color="gray")
            )
        ),

        # Actions
        rx.hstack(
            rx.button("View Details", size="2"),
            rx.button("Pause", size="2", color_scheme="orange"),
            rx.button("View Responses", size="2", color_scheme="blue")
        ),

        padding="1rem",
        border="1px solid #e5e7eb",
        border_radius="8px",
        margin_bottom="1rem"
    )
```

#### 3. **Stock Alerts** (Custom Page)
```python
def stock_alerts_page() -> rx.Component:
    return rx.vstack(
        rx.heading("Stock Alert Queue"),

        # Pending alerts
        rx.box(
            rx.heading(f"{DashboardState.pending_alerts_count} Pending Alerts", size="5"),

            rx.data_table(
                data=DashboardState.pending_alerts,
                columns=[
                    {"key": "customer_name", "label": "Customer"},
                    {"key": "product_name", "label": "Product"},
                    {"key": "channel", "label": "Channel"},
                    {"key": "requested_date", "label": "Requested"},
                    {"key": "priority", "label": "Priority"},
                    {"key": "actions", "label": "Actions"}
                ]
            )
        ),

        # Bulk actions
        rx.hstack(
            rx.input(
                placeholder="Product Name",
                value=DashboardState.stock_product_name,
                on_change=DashboardState.set_stock_product_name
            ),
            rx.button(
                "✅ Mark as In Stock & Notify All",
                on_click=DashboardState.trigger_stock_notifications,
                color_scheme="green",
                size="3"
            )
        )
    )
```

#### 4. **Priority Dashboard** (Custom Page)
```python
def priority_dashboard() -> rx.Component:
    return rx.vstack(
        rx.heading("Priority Queue"),

        # HIGH PRIORITY
        rx.box(
            rx.heading("🔴 HIGH PRIORITY - Needs Immediate Attention", color="red"),
            rx.text(f"{DashboardState.high_priority_count} messages", color="gray"),

            rx.foreach(
                DashboardState.high_priority_messages,
                lambda msg: priority_message_card(
                    msg,
                    color="red",
                    actions=[
                        rx.button("Take Over", on_click=lambda: take_over(msg["id"])),
                        rx.button("View in Chatwoot", on_click=lambda: open_chatwoot(msg["conversation_id"]))
                    ]
                )
            )
        ),

        # MEDIUM PRIORITY
        rx.box(
            rx.heading("🟡 AGENT HANDLING - Human can review", color="orange"),
            rx.text(f"{DashboardState.medium_priority_count} conversations", color="gray"),

            rx.foreach(
                DashboardState.medium_priority_messages,
                lambda msg: priority_message_card(msg, color="orange")
            )
        ),

        # LOW PRIORITY (AUTO-HANDLED)
        rx.box(
            rx.heading("🟢 AUTO-HANDLED", color="green"),
            rx.text(f"{DashboardState.auto_handled_today} messages today", color="gray")
        )
    )
```

---

## 🚀 Updated Tech Stack

### Core Dependencies

```python
# requirements.txt UPDATE

# ============ MULTI-AGENT ORCHESTRATION ============
langgraph==0.2.62              # LangGraph state machines
langchain==0.3.15              # LangChain framework
langchain-anthropic==0.3.5     # Claude integration
langchain-openai==0.3.1        # GPT integration
langchain-community==0.3.10    # Community integrations

# ============ CORE AGENT FRAMEWORK ============
pydantic-ai>=0.0.14            # Agent 1: Structured extraction (fixed griffe)
anthropic==0.42.0              # Agent 2: Claude SDK for conversation
openai==1.59.5                 # For GPT-4o-mini + embeddings

# ============ CHATWOOT INTEGRATION ============
httpx==0.28.1                  # Async HTTP client for Chatwoot API

# ============ WEB FRAMEWORK ============
fastapi==0.115.6               # API backend
uvicorn[standard]==0.34.0      # ASGI server
python-multipart==0.0.20       # File upload support

# ============ DATABASE ============
supabase==2.22.0               # Supabase client (PostgreSQL + Auth + Storage)
pgvector==0.3.6                # PGVector extension for vector search
psycopg2-binary==2.9.10        # PostgreSQL adapter

# ============ DATA VALIDATION ============
pydantic==2.10.4               # Type validation
pydantic-settings==2.7.1       # Settings management

# ============ WHATSAPP INTEGRATION ============
requests==2.32.3               # HTTP requests for 360Dialog API

# ============ BACKGROUND JOBS ============
celery==5.4.0                  # Task queue (for stock monitoring)
redis==5.2.1                   # Celery broker

# ============ ENVIRONMENT ============
python-dotenv==1.0.1           # .env file support

# ============ TESTING ============
pytest==8.3.4                  # Testing framework
pytest-asyncio==0.25.2         # Async test support
pytest-cov==6.0.0              # Coverage reporting

# ============ DASHBOARD (REFLEX) ============
reflex==0.6.5                  # Modern Python web framework

# ============ DEVELOPMENT ============
black==24.10.0                 # Code formatting
ruff==0.8.5                    # Linting
mypy==1.14.1                   # Type checking
```

### Infrastructure Stack

```yaml
# docker-compose.yml

version: '3.8'

services:
  # FastAPI Backend
  api:
    build:
      context: .
      dockerfile: Dockerfile.api
    container_name: recruitment-api
    ports:
      - "8000:8000"
    environment:
      # AI Models
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
      - OPENAI_API_KEY=${OPENAI_API_KEY}

      # Database
      - SUPABASE_URL=${SUPABASE_URL}
      - SUPABASE_SERVICE_KEY=${SUPABASE_SERVICE_KEY}

      # Chatwoot
      - CHATWOOT_URL=http://chatwoot:3000
      - CHATWOOT_API_TOKEN=${CHATWOOT_API_TOKEN}
      - CHATWOOT_ACCOUNT_ID=${CHATWOOT_ACCOUNT_ID}

      # WhatsApp
      - THREESIXTY_DIALOG_API_KEY=${THREESIXTY_DIALOG_API_KEY}
    depends_on:
      - chatwoot
      - redis
    networks:
      - recruitment-network

  # Chatwoot (Multi-Channel Inbox)
  chatwoot:
    image: chatwoot/chatwoot:latest
    container_name: chatwoot
    ports:
      - "3000:3000"
    environment:
      - SECRET_KEY_BASE=${CHATWOOT_SECRET_KEY}
      - POSTGRES_HOST=chatwoot-db
      - POSTGRES_USERNAME=postgres
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DATABASE=chatwoot_production
      - REDIS_URL=redis://redis:6379
      - RAILS_ENV=production
      - INSTALLATION_ENV=docker
    depends_on:
      - chatwoot-db
      - redis
    networks:
      - recruitment-network

  # PostgreSQL (for Chatwoot)
  chatwoot-db:
    image: postgres:14-alpine
    container_name: chatwoot-db
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=chatwoot_production
    volumes:
      - chatwoot-data:/var/lib/postgresql/data
    networks:
      - recruitment-network

  # Redis (for Chatwoot + Celery)
  redis:
    image: redis:7-alpine
    container_name: redis
    ports:
      - "6379:6379"
    networks:
      - recruitment-network

  # Celery Worker (Background Jobs)
  celery:
    build:
      context: .
      dockerfile: Dockerfile.api
    container_name: celery-worker
    command: celery -A agent.celery_app worker --loglevel=info
    environment:
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - SUPABASE_URL=${SUPABASE_URL}
      - CHATWOOT_URL=http://chatwoot:3000
      - REDIS_URL=redis://redis:6379
    depends_on:
      - redis
      - api
    networks:
      - recruitment-network

  # Reflex Dashboard
  dashboard:
    build:
      context: .
      dockerfile: Dockerfile.dashboard
    container_name: recruitment-dashboard
    ports:
      - "3002:3002"
      - "8001:8001"
    environment:
      - API_BASE_URL=http://api:8000
      - CHATWOOT_URL=http://chatwoot:3000
    depends_on:
      - api
      - chatwoot
    networks:
      - recruitment-network

networks:
  recruitment-network:
    driver: bridge

volumes:
  chatwoot-data:
```

---

## 📈 Cost Analysis v4.0

### Per-Conversation Costs

| Component | Model | Cost per Conversation |
|-----------|-------|----------------------|
| Router Agent | GPT-4o-mini | $0.001 |
| Agent 1 (Extraction) | GPT-4o-mini | $0.003 (every 5 msgs) |
| Agent 2 (Conversation) | Claude 3.5 Sonnet | $0.15 (10 messages) |
| Agent 3 (Campaign) | Claude 3.5 Sonnet | $0.10 per DM |
| Agent 4 (CRM) | GPT-4o-mini | $0.001 per operation |
| **TOTAL** | - | **~$0.155 per conversation** |

### Monthly Infrastructure

| Service | Cost |
|---------|------|
| Chatwoot (self-hosted) | $0 (Docker) |
| PostgreSQL | $0 (included) |
| Redis | $0 (included) |
| Supabase Free Tier | $0 |
| 360Dialog (WhatsApp) | $45-150/month |
| Meta Business (Instagram) | $0 |
| **TOTAL INFRA** | **$45-150/month** |

### Volume Pricing

**At 100 conversations/month:**
- AI costs: $15.50
- Infrastructure: $45-150
- **Total: $60.50 - $165.50/month**

**At 500 conversations/month:**
- AI costs: $77.50
- Infrastructure: $45-150
- **Total: $122.50 - $227.50/month**

**Still cheaper than enterprise SaaS** (Intercom: €74/mo base + €0.99/conversation)

---

## 🎯 Use Cases Enabled

### Use Case 1: Multi-Channel Lead Qualification
**Before (v3.0)**: WhatsApp only
**After (v4.0)**: Instagram DM + WhatsApp + Email + SMS

**Flow:**
1. Lead messages from ANY channel
2. Chatwoot receives + webhooks to us
3. LangGraph Router classifies priority
4. Agent 2 converses naturally
5. Agent 1 extracts qualification data
6. CRM auto-updates with tags
7. Human sees prioritized view

### Use Case 2: Product DM Campaigns
**New in v4.0!**

**Scenario**: Beauty brand launches new product, wants to DM 50 Instagram followers

**Flow:**
1. User inputs: Product URL, target count, channel
2. Agent 3 analyzes product (features, benefits, USPs)
3. Agent 3 generates 50 personalized DMs
4. Send via Chatwoot Instagram inbox
5. Monitor responses
6. Agent 2 answers questions
7. Escalate to human if complex
8. Track conversions

### Use Case 3: Stock Alert System
**New in v4.0!**

**Scenario**: Customer asks "Let me know when these sneakers are back in stock"

**Flow:**
1. Router detects `intent = "stock_alert"`
2. Agent 1 extracts product name
3. Agent 4 creates CRM entry:
   - Product requested
   - Full chat history
   - Channel for later notification
4. Chatwoot contact tagged: "STOCK_ALERT", "IMPORTANT"
5. Agent 2 confirms: "I'll message you as soon as they're available!"
6. **Background job** (Celery) checks stock hourly
7. When in stock:
   - Agent 4 retrieves all waiting customers
   - Generates personalized notification per customer
   - Sends via original channel (Instagram/WhatsApp)
   - CRM updated: `status = "notified"`

### Use Case 4: Priority Routing
**New in v4.0!**

**Scenario**: 100 messages come in across WhatsApp, Instagram, Email

**Flow:**
1. Router Agent analyzes each message:
   - **High priority**: Complaint, purchase intent, VIP customer → Immediate human notification
   - **Medium priority**: Product question, general inquiry → Agent handles, human can review
   - **Low priority**: FAQ, spam → Fully automated
2. Dashboard shows prioritized queue
3. Human focuses on high-value interactions
4. Agents handle 80% automatically

---

## 🔄 Migration from v3.0 to v4.0

### What We Keep
✅ Agent 1 (Pydantic AI) - Extraction logic
✅ Agent 2 (Claude SDK) - Conversation logic
✅ Supabase database
✅ FastAPI backend
✅ 360Dialog WhatsApp integration
✅ RAG system (PGVector embeddings)

### What We Add
🆕 LangGraph orchestration layer
🆕 Chatwoot multi-channel inbox
🆕 Agent 3 (Campaign Agent)
🆕 Agent 4 (CRM Agent)
🆕 Router Agent
🆕 Stock alert system
🆕 Campaign management
🆕 Priority routing
🆕 Celery background jobs

### What We Replace
❌ Custom dashboard → Chatwoot embedded
❌ Simple orchestration → LangGraph state machines
❌ Single channel → Multi-channel

---

## 📝 Next Steps for Implementation

### Phase 1: Foundation (Week 1)
- [ ] Install LangGraph + LangChain
- [ ] Add Chatwoot to docker-compose
- [ ] Setup Chatwoot account + API keys
- [ ] Create database migrations (new tables)

### Phase 2: Core Integration (Week 2)
- [ ] Build Router Agent (priority classification)
- [ ] Integrate Chatwoot webhooks → FastAPI
- [ ] Build Chatwoot API client
- [ ] Test message flow: Chatwoot → LangGraph → Chatwoot

### Phase 3: Advanced Features (Week 3)
- [ ] Build Campaign workflow (Agent 3)
- [ ] Build Stock Alert workflow (Agent 4)
- [ ] Implement Celery background jobs
- [ ] Create CRM automation rules

### Phase 4: Dashboard (Week 4)
- [ ] Update Reflex dashboard with Chatwoot iframe
- [ ] Build custom widgets (Priority Queue, Campaigns)
- [ ] Add Stock Alert Manager page
- [ ] Testing + polishing

---

## ✅ Success Criteria

### Technical
- [ ] Messages processed in < 2 seconds
- [ ] 95%+ uptime
- [ ] < 5% error rate
- [ ] All channels working (WhatsApp, Instagram, Email)

### Business
- [ ] 80% of conversations handled by agents
- [ ] Human only needed for 20% (high-value interactions)
- [ ] Campaign conversion rate > 10%
- [ ] Stock alert system operational

### User Experience
- [ ] Natural conversations across all channels
- [ ] Instant responses (< 3 seconds)
- [ ] Smooth human takeover
- [ ] Easy campaign management

---

**End of PRD v4.0**
