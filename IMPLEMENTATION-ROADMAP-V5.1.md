# üìã IMPLEMENTATION ROADMAP v5.1
## Chatwoot-Centric WhatsApp Recruitment Platform

**Version**: 1.0
**Target Duration**: 8 weeks (solo developer)
**Architecture**: Chatwoot + LangGraph + 4 Agents
**PRD Reference**: PRD-V5.1-CHATWOOT-CENTRIC.md

---

## üìä TIMELINE OVERVIEW

### Gantt Chart (8 Weeks)
```
Week | Foundation | Agents | RAG | CRM | Production | White-Label | Testing | Deploy |
-----|------------|--------|-----|-----|------------|-------------|---------|--------|
W1   |‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà|        |     |     |            |             |         |        |
W2   |‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà|        |     |     |            |             |         |        |
W3   |            |‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà|     |     |            |             |         |        |
W4   |            |‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà|     |     |            |             |         |        |
W5   |            |        |‚ñà‚ñà‚ñà‚ñà‚ñà|     |            |             |         |        |
W6   |            |        |     |‚ñà‚ñà‚ñà‚ñà‚ñà|            |             |         |        |
W7   |            |        |     |     |‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà|             |         |        |
W8   |            |        |     |     |            |‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà|
```

### Milestones Table
| Week | Milestone | Deliverables | Success Criteria |
|------|-----------|--------------|------------------|
| 1-2 | Foundation Setup | Chatwoot deployed, WhatsApp MCP working, FastAPI webhook | Echo bot works end-to-end |
| 3-4 | LangGraph + Agents | 4 agents implemented, state machine working | Full conversation flow with CRM updates |
| 5 | Agentic RAG | Vector DB populated, tool calling working | Agent autonomously searches knowledge base |
| 6 | CRM Integration | Custom attributes, labels, human takeover | Full CRM profile with AI summaries |
| 7 | Production Services | 360Dialog, ScrapeCreators import, rate limiting | Production WhatsApp, lead import working |
| 8 | Launch | White-label branding, testing, deployment | System live with client branding |

### Critical Path
```
Foundation (W1-2)
    ‚Üí LangGraph Setup (W3)
    ‚Üí Agents Implementation (W3-4)
    ‚Üí Agentic RAG (W5)
    ‚Üí CRM Integration (W6)
    ‚Üí Production Services (W7)
    ‚Üí Testing & Deploy (W8)
```

---

## üóìÔ∏è WEEK 1-2: FOUNDATION SETUP

### Goals
- Deploy Chatwoot on Railway
- Setup WhatsApp MCP for development testing
- Implement FastAPI webhook receiver
- Create basic echo bot (WhatsApp ‚Üí Chatwoot ‚Üí FastAPI ‚Üí WhatsApp)

### Technical Tasks

#### Day 1-2: Chatwoot Deployment
**Task 1.1: Railway Project Setup**
```bash
# Clone Chatwoot
git clone https://github.com/chatwoot/chatwoot.git
cd chatwoot

# Create Railway project
railway login
railway init
railway link

# Add PostgreSQL and Redis
railway add --plugin postgresql
railway add --plugin redis
```

**Task 1.2: Environment Configuration**
```bash
# Create .env file
cat > .env << EOF
# Chatwoot Core
RAILS_ENV=production
SECRET_KEY_BASE=$(openssl rand -hex 64)

# Database (Railway auto-provided)
DATABASE_URL=postgresql://user:pass@host:5432/chatwoot_production
REDIS_URL=redis://host:6379

# Chatwoot Config
FRONTEND_URL=https://your-app.railway.app
FORCE_SSL=true
ENABLE_ACCOUNT_SIGNUP=false

# Storage (for media files)
ACTIVE_STORAGE_SERVICE=local

# Branding (White-label prep)
BRAND_NAME=RecruitmentCRM
LOGO_THUMBNAIL=https://yourcompany.com/logo-small.png
LOGO=https://yourcompany.com/logo-large.png
WIDGET_BRAND_URL=
EOF
```

**Task 1.3: Deploy to Railway**
```bash
# Build and deploy
railway up

# Run migrations
railway run rails db:create
railway run rails db:migrate
railway run rails db:seed

# Create super admin
railway run rails runner "User.create!(email: 'admin@example.com', password: 'password', role: :administrator)"
```

**Testing Checklist**:
- [ ] Chatwoot UI accessible at Railway URL
- [ ] Can login with admin credentials
- [ ] Dashboard loads without errors
- [ ] PostgreSQL connected
- [ ] Redis connected

---

#### Day 3-4: WhatsApp MCP Integration (Development)
**Task 2.1: Install WhatsApp MCP**
```bash
# Install MCP CLI
npm install -g @modelcontextprotocol/cli

# Install WhatsApp MCP server
npm install -g @chatwoot/whatsapp-mcp-server

# Or clone from repo
git clone https://github.com/chatwoot/whatsapp-mcp-server.git
cd whatsapp-mcp-server
npm install
npm run build
```

**Task 2.2: Configure WhatsApp Inbox in Chatwoot**
```bash
# 1. Login to Chatwoot
# 2. Navigate to: Settings ‚Üí Inboxes ‚Üí Add Inbox
# 3. Select: WhatsApp
# 4. Choose: WhatsApp Cloud (MCP Server)
# 5. Configure:
#    - Phone Number: +31612345678 (your test number)
#    - Webhook URL: https://your-app.railway.app/webhooks/whatsapp
#    - API Key: (auto-generated by Chatwoot)
```

**Task 2.3: Start WhatsApp MCP Server**
```javascript
// whatsapp-mcp-config.json
{
  "mcpServers": {
    "whatsapp": {
      "command": "npx",
      "args": ["-y", "@chatwoot/whatsapp-mcp-server"],
      "env": {
        "WHATSAPP_PHONE_NUMBER": "+31612345678",
        "CHATWOOT_WEBHOOK_URL": "https://your-app.railway.app/webhooks/whatsapp",
        "CHATWOOT_API_TOKEN": "your_chatwoot_api_token"
      }
    }
  }
}
```

```bash
# Start MCP server
npx @modelcontextprotocol/cli run whatsapp-mcp-config.json
```

**Testing Checklist**:
- [ ] MCP server running without errors
- [ ] WhatsApp inbox appears in Chatwoot
- [ ] Can send test message from phone
- [ ] Message appears in Chatwoot inbox
- [ ] Agent reply sent to phone

---

#### Day 5-7: FastAPI Webhook Receiver
**Task 3.1: Project Setup**
```bash
# Create project structure
mkdir chatwoot-webhook-service
cd chatwoot-webhook-service

# Initialize Python environment
python3 -m venv venv
source venv/bin/activate

# Install dependencies
pip install fastapi uvicorn httpx pydantic pydantic-settings python-dotenv
pip freeze > requirements.txt
```

**Task 3.2: FastAPI Application**
```python
# main.py
from fastapi import FastAPI, Request, HTTPException
from pydantic import BaseModel
from typing import Optional, Literal
import httpx
import os
from dotenv import load_dotenv

load_dotenv()

app = FastAPI(title="Chatwoot Webhook Service")

# Environment variables
CHATWOOT_URL = os.getenv("CHATWOOT_URL")
CHATWOOT_API_TOKEN = os.getenv("CHATWOOT_API_TOKEN")
CHATWOOT_ACCOUNT_ID = os.getenv("CHATWOOT_ACCOUNT_ID")

# Pydantic models
class ChatwootMessage(BaseModel):
    id: int
    content: str
    message_type: Literal["incoming", "outgoing"]
    created_at: int
    conversation_id: int
    sender: dict
    contact_id: int

class ChatwootWebhookPayload(BaseModel):
    event: str
    account_id: int
    id: int
    message: Optional[ChatwootMessage] = None
    conversation: Optional[dict] = None

@app.get("/")
async def root():
    return {"status": "Chatwoot Webhook Service Running", "version": "1.0"}

@app.post("/webhooks/chatwoot")
async def chatwoot_webhook(payload: ChatwootWebhookPayload):
    """
    Receive Chatwoot webhooks and process messages.

    Events:
    - message_created: New message from user
    - conversation_created: New conversation started
    - conversation_status_changed: Status updated
    """

    print(f"üì© Received event: {payload.event}")

    # Only process incoming messages
    if payload.event == "message_created" and payload.message:
        message = payload.message

        # Skip outgoing messages (from agent/bot)
        if message.message_type == "outgoing":
            print("‚è≠Ô∏è Skipping outgoing message")
            return {"status": "skipped"}

        print(f"üí¨ Processing message: {message.content}")

        # Echo bot: Reply with same message
        response = await send_message_to_chatwoot(
            conversation_id=message.conversation_id,
            content=f"Echo: {message.content}"
        )

        return {"status": "processed", "response": response}

    return {"status": "ignored"}

async def send_message_to_chatwoot(conversation_id: int, content: str):
    """Send message back to Chatwoot (which forwards to WhatsApp)"""

    url = f"{CHATWOOT_URL}/api/v1/accounts/{CHATWOOT_ACCOUNT_ID}/conversations/{conversation_id}/messages"

    async with httpx.AsyncClient() as client:
        response = await client.post(
            url,
            headers={"api_access_token": CHATWOOT_API_TOKEN},
            json={
                "content": content,
                "message_type": "outgoing",
                "private": False
            }
        )

        if response.status_code != 200:
            raise HTTPException(500, f"Failed to send message: {response.text}")

        return response.json()

@app.get("/health")
async def health_check():
    """Health check endpoint for Railway"""
    return {"status": "healthy"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

**Task 3.3: Environment File**
```bash
# .env
CHATWOOT_URL=https://your-app.railway.app
CHATWOOT_API_TOKEN=your_api_token_here
CHATWOOT_ACCOUNT_ID=1
```

**Task 3.4: Deploy FastAPI to Railway**
```bash
# Create Dockerfile
cat > Dockerfile << EOF
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 8000

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
EOF

# Deploy to Railway
railway init
railway link
railway up
```

**Task 3.5: Configure Chatwoot Webhook**
```bash
# In Chatwoot UI:
# Settings ‚Üí Webhooks ‚Üí Add Webhook
# URL: https://your-fastapi.railway.app/webhooks/chatwoot
# Events: message_created, conversation_created
# Save
```

**Testing Checklist**:
- [ ] FastAPI running at Railway URL
- [ ] `/health` endpoint returns 200
- [ ] Send WhatsApp message
- [ ] FastAPI receives webhook
- [ ] Echo response sent back
- [ ] User receives echo on WhatsApp

---

#### Day 8-10: Supabase PGVector Setup
**Task 4.1: Create Supabase Project**
```bash
# 1. Go to https://supabase.com
# 2. Create new project
# 3. Note down:
#    - Project URL
#    - API Key (anon public)
#    - Service Role Key (secret)
#    - Database Password
```

**Task 4.2: Enable PGVector Extension**
```sql
-- In Supabase SQL Editor
CREATE EXTENSION IF NOT EXISTS vector;
```

**Task 4.3: Create Documents Table**
```sql
-- documents table for RAG knowledge base
CREATE TABLE documents (
    id SERIAL PRIMARY KEY,
    content TEXT NOT NULL,
    embedding VECTOR(1536),  -- OpenAI text-embedding-3-small
    metadata JSONB,
    category VARCHAR(50),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- Index for fast similarity search
CREATE INDEX ON documents
USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 100);

-- Function for vector similarity search
CREATE OR REPLACE FUNCTION match_documents(
    query_embedding VECTOR(1536),
    match_threshold FLOAT DEFAULT 0.7,
    match_count INT DEFAULT 5,
    filter_category VARCHAR DEFAULT NULL
)
RETURNS TABLE (
    id INT,
    content TEXT,
    metadata JSONB,
    category VARCHAR,
    similarity FLOAT
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT
        documents.id,
        documents.content,
        documents.metadata,
        documents.category,
        1 - (documents.embedding <=> query_embedding) AS similarity
    FROM documents
    WHERE
        (filter_category IS NULL OR documents.category = filter_category)
        AND 1 - (documents.embedding <=> query_embedding) > match_threshold
    ORDER BY similarity DESC
    LIMIT match_count;
END;
$$;
```

**Task 4.4: Python Client Setup**
```python
# supabase_client.py
from supabase import create_client, Client
import os
from typing import List, Dict, Optional

SUPABASE_URL = os.getenv("SUPABASE_URL")
SUPABASE_KEY = os.getenv("SUPABASE_SERVICE_KEY")

supabase: Client = create_client(SUPABASE_URL, SUPABASE_KEY)

async def insert_document(
    content: str,
    embedding: List[float],
    metadata: Dict,
    category: str
) -> Dict:
    """Insert document with embedding into Supabase"""

    response = supabase.table("documents").insert({
        "content": content,
        "embedding": embedding,
        "metadata": metadata,
        "category": category
    }).execute()

    return response.data[0]

async def search_documents(
    query_embedding: List[float],
    match_threshold: float = 0.7,
    match_count: int = 5,
    category: Optional[str] = None
) -> List[Dict]:
    """Search for similar documents using vector search"""

    response = supabase.rpc(
        "match_documents",
        {
            "query_embedding": query_embedding,
            "match_threshold": match_threshold,
            "match_count": match_count,
            "filter_category": category
        }
    ).execute()

    return response.data
```

**Testing Checklist**:
- [ ] Supabase project created
- [ ] PGVector extension enabled
- [ ] Documents table created
- [ ] Can insert test document
- [ ] Can run similarity search
- [ ] Python client connects successfully

---

### Week 1-2 Deliverables
- ‚úÖ Chatwoot deployed and accessible
- ‚úÖ WhatsApp MCP working (development mode)
- ‚úÖ FastAPI webhook receiving Chatwoot events
- ‚úÖ Echo bot working end-to-end
- ‚úÖ Supabase PGVector configured
- ‚úÖ Docker Compose local environment

### Testing Checklist (Week 1-2)
```bash
# End-to-End Test
1. Send WhatsApp message: "Hello"
2. Message appears in Chatwoot inbox
3. FastAPI logs show webhook received
4. Echo response: "Echo: Hello"
5. User receives response on WhatsApp

‚úÖ PASS: Foundation working correctly
```

---

## üóìÔ∏è WEEK 3-4: LANGGRAPH + 4 AGENTS

### Goals
- Implement LangGraph state machine
- Create 4 agents: Router, Extraction, Conversation, CRM
- End-to-end conversation flow with CRM updates

### Technical Tasks

#### Day 1-3: LangGraph Setup
**Task 5.1: Install Dependencies**
```bash
pip install langgraph==0.2.62
pip install langchain==0.3.14
pip install langchain-openai==0.2.14
pip install langchain-anthropic==0.3.7
pip install pydantic-ai>=0.0.14
pip install openai==1.59.5
pip install anthropic==0.42.0
```

**Task 5.2: State Definition**
```python
# state.py
from typing import TypedDict, Literal, Optional, List, Dict
from pydantic import BaseModel

class ConversationState(TypedDict):
    """LangGraph state for conversation flow"""

    # Chatwoot context
    message_id: str
    conversation_id: str
    contact_id: str
    account_id: str
    channel: Literal["whatsapp", "instagram", "email", "telegram"]

    # Message content
    message_content: str
    message_type: Literal["incoming", "outgoing"]

    # Agent outputs
    intent: Optional[str]
    priority: Optional[Literal["high", "medium", "low"]]
    sentiment: Optional[float]  # -1.0 to 1.0

    extracted_data: Optional[Dict]  # From Extraction Agent
    rag_results: Optional[List[Dict]]  # From Agentic RAG
    agent_response: Optional[str]  # From Conversation Agent

    # Routing
    needs_human: bool
    route: Optional[Literal["automated", "human", "hybrid"]]

    # Context
    contact_profile: Optional[Dict]
    conversation_history: Optional[List[Dict]]

    # Error handling
    error: Optional[str]
    retry_count: int

class ExtractedData(BaseModel):
    """Structured data extracted by Pydantic AI"""
    name: Optional[str] = None
    email: Optional[str] = None
    phone: Optional[str] = None
    budget_min: Optional[int] = None
    budget_max: Optional[int] = None
    job_type: Optional[Literal["interim", "permanent", "freelance"]] = None
    urgency: Literal["high", "medium", "low"] = "medium"
    intent: str
    key_phrases: List[str] = []
```

**Task 5.3: Graph Definition**
```python
# graph.py
from langgraph.graph import StateGraph, END, START
from state import ConversationState
from agents import (
    router_agent_node,
    extraction_agent_node,
    conversation_agent_node,
    crm_agent_node
)

def create_conversation_graph():
    """Create LangGraph conversation workflow"""

    # Initialize graph
    graph = StateGraph(ConversationState)

    # Add nodes (agents)
    graph.add_node("router", router_agent_node)
    graph.add_node("extraction", extraction_agent_node)
    graph.add_node("conversation", conversation_agent_node)
    graph.add_node("crm", crm_agent_node)

    # Add edges
    graph.add_edge(START, "router")
    graph.add_edge("router", "extraction")

    # Conditional edge: Check if human needed
    def should_route_to_human(state: ConversationState) -> str:
        """Decide if human takeover needed"""

        # High priority or complaint
        if state.get("priority") == "high":
            state["needs_human"] = True
            state["route"] = "human"
            return END

        # Negative sentiment
        if state.get("sentiment", 0) < -0.5:
            state["needs_human"] = True
            state["route"] = "human"
            return END

        # Complex intent
        complex_intents = ["complaint", "refund", "escalation"]
        if state.get("intent") in complex_intents:
            state["needs_human"] = True
            state["route"] = "human"
            return END

        # Continue to conversation agent
        state["needs_human"] = False
        state["route"] = "automated"
        return "conversation"

    graph.add_conditional_edges(
        "extraction",
        should_route_to_human,
        {
            "conversation": "conversation",
            END: END
        }
    )

    graph.add_edge("conversation", "crm")
    graph.add_edge("crm", END)

    # Compile
    app = graph.compile()

    return app

# Create singleton instance
conversation_app = create_conversation_graph()
```

**Testing Checklist**:
- [ ] LangGraph imports successfully
- [ ] State definition valid
- [ ] Graph compiles without errors
- [ ] Can visualize graph (optional)

---

#### Day 4-6: Agent 1 - Router Agent
**Task 6.1: Router Implementation**
```python
# agents/router_agent.py
from openai import AsyncOpenAI
from state import ConversationState
import os

client = AsyncOpenAI(api_key=os.getenv("OPENAI_API_KEY"))

ROUTER_SYSTEM_PROMPT = """You are a routing agent. Classify the user's message intent.

Categories:
- product_inquiry: Questions about products/services
- policy_question: Return policy, terms, FAQ
- support_request: Help with issues, complaints
- job_search: Looking for jobs, vacancies (recruitment use case)
- general: Greetings, chitchat
- qualification: Lead qualification questions
- complaint: Negative feedback, complaints
- order_status: Tracking, order updates

Output format (JSON):
{
    "intent": "category_name",
    "priority": "high|medium|low",
    "sentiment": 0.5,
    "confidence": 0.9
}

Priority rules:
- high: Complaints, urgent requests, refunds
- medium: Product inquiries, support requests
- low: General chitchat, greetings

Sentiment: -1.0 (very negative) to 1.0 (very positive)
"""

async def router_agent_node(state: ConversationState) -> ConversationState:
    """
    Router Agent: Classify message intent and priority
    Model: GPT-4o-mini (fast + cheap)
    """

    print(f"üîÄ Router Agent processing: {state['message_content'][:50]}...")

    try:
        response = await client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[
                {"role": "system", "content": ROUTER_SYSTEM_PROMPT},
                {"role": "user", "content": state["message_content"]}
            ],
            response_format={"type": "json_object"},
            temperature=0.3
        )

        result = response.choices[0].message.content
        import json
        parsed = json.loads(result)

        # Update state
        state["intent"] = parsed.get("intent", "general")
        state["priority"] = parsed.get("priority", "medium")
        state["sentiment"] = parsed.get("sentiment", 0.0)

        print(f"‚úÖ Routed: intent={state['intent']}, priority={state['priority']}")

    except Exception as e:
        print(f"‚ùå Router error: {e}")
        state["error"] = str(e)
        state["intent"] = "general"
        state["priority"] = "medium"

    return state
```

**Testing**:
```python
# test_router.py
import asyncio
from agents.router_agent import router_agent_node
from state import ConversationState

async def test_router():
    test_cases = [
        "I want to return my order #123",  # Expected: complaint, high
        "What's your return policy?",      # Expected: policy_question, medium
        "Hello!",                           # Expected: general, low
        "Looking for tech jobs",            # Expected: job_search, medium
    ]

    for message in test_cases:
        state: ConversationState = {
            "message_content": message,
            "message_id": "test",
            "conversation_id": "test",
            "contact_id": "test",
            "account_id": "1",
            "channel": "whatsapp",
            "message_type": "incoming",
            "needs_human": False,
            "retry_count": 0
        }

        result = await router_agent_node(state)
        print(f"\nMessage: {message}")
        print(f"Intent: {result['intent']}")
        print(f"Priority: {result['priority']}")
        print(f"Sentiment: {result['sentiment']}")

asyncio.run(test_router())
```

---

#### Day 7-9: Agent 2 - Extraction Agent
**Task 7.1: Pydantic AI Implementation**
```python
# agents/extraction_agent.py
from pydantic_ai import Agent
from state import ConversationState, ExtractedData
import os

EXTRACTION_SYSTEM_PROMPT = """Extract structured contact and lead data from conversations.

Rules:
- Extract name if mentioned
- Extract email if provided
- Extract phone if provided
- Detect budget range (min/max)
- Identify job type preference (interim, permanent, freelance)
- Determine urgency level (high, medium, low)
- Extract key phrases for CRM
- Classify intent

If information not present, return None for that field.
"""

# Initialize Pydantic AI agent
extraction_agent = Agent(
    'openai:gpt-4o-mini',
    result_type=ExtractedData,
    system_prompt=EXTRACTION_SYSTEM_PROMPT
)

async def extraction_agent_node(state: ConversationState) -> ConversationState:
    """
    Extraction Agent: Extract structured data using Pydantic AI
    Model: GPT-4o-mini with Pydantic validation
    """

    print(f"üìä Extraction Agent processing: {state['message_content'][:50]}...")

    try:
        # Run Pydantic AI agent
        result = await extraction_agent.run(state["message_content"])

        # result.data is already validated ExtractedData instance!
        extracted = result.data

        # Convert to dict for state
        state["extracted_data"] = extracted.model_dump()

        print(f"‚úÖ Extracted: {extracted.model_dump()}")

    except Exception as e:
        print(f"‚ùå Extraction error: {e}")
        state["error"] = str(e)
        state["extracted_data"] = None

    return state
```

**Testing**:
```python
# test_extraction.py
import asyncio
from agents.extraction_agent import extraction_agent_node
from state import ConversationState

async def test_extraction():
    test_cases = [
        "Hi, I'm John Doe. Looking for interim roles, budget ‚Ç¨70-90k",
        "My email is john@example.com, phone +31612345678",
        "Need urgent freelance work, budget around ‚Ç¨5000",
    ]

    for message in test_cases:
        state: ConversationState = {
            "message_content": message,
            "message_id": "test",
            "conversation_id": "test",
            "contact_id": "test",
            "account_id": "1",
            "channel": "whatsapp",
            "message_type": "incoming",
            "needs_human": False,
            "retry_count": 0,
            "intent": "job_search",
            "priority": "medium"
        }

        result = await extraction_agent_node(state)
        print(f"\nMessage: {message}")
        print(f"Extracted: {result['extracted_data']}")

asyncio.run(test_extraction())
```

---

#### Day 10-12: Agent 3 - Conversation Agent (Basic)
**Task 8.1: Conversation Agent (Without RAG)**
```python
# agents/conversation_agent.py
from anthropic import AsyncAnthropic
from state import ConversationState
import os

client = AsyncAnthropic(api_key=os.getenv("ANTHROPIC_API_KEY"))

CONVERSATION_SYSTEM_PROMPT = """You are a helpful recruitment assistant.

Your role:
- Answer questions about job opportunities
- Qualify leads for recruitment services
- Provide information about available positions
- Be professional, friendly, and concise

Guidelines:
- Keep responses under 200 words
- Ask clarifying questions when needed
- If you don't know, say so politely
- Encourage contact information exchange

Context will be provided for each conversation.
"""

async def conversation_agent_node(state: ConversationState) -> ConversationState:
    """
    Conversation Agent: Generate responses using Claude
    Model: Claude 3.5 Sonnet (without Agentic RAG for now)
    """

    print(f"üí¨ Conversation Agent processing: {state['message_content'][:50]}...")

    try:
        # Build context from state
        context = f"""
User message: {state['message_content']}
Intent: {state.get('intent', 'unknown')}
Priority: {state.get('priority', 'medium')}
Extracted data: {state.get('extracted_data', {})}
        """

        # Call Claude
        response = await client.messages.create(
            model="claude-3-5-sonnet-20241022",
            max_tokens=1024,
            system=CONVERSATION_SYSTEM_PROMPT,
            messages=[
                {"role": "user", "content": context}
            ]
        )

        # Extract response text
        agent_response = response.content[0].text
        state["agent_response"] = agent_response

        print(f"‚úÖ Response generated: {agent_response[:100]}...")

    except Exception as e:
        print(f"‚ùå Conversation error: {e}")
        state["error"] = str(e)
        state["agent_response"] = "I apologize, I'm having trouble processing your request. A human agent will assist you shortly."
        state["needs_human"] = True

    return state
```

**Note**: Agentic RAG will be added in Week 5

---

#### Day 13-14: Agent 4 - CRM Agent
**Task 9.1: CRM Update Implementation**
```python
# agents/crm_agent.py
from state import ConversationState
import httpx
import os

CHATWOOT_URL = os.getenv("CHATWOOT_URL")
CHATWOOT_API_TOKEN = os.getenv("CHATWOOT_API_TOKEN")
CHATWOOT_ACCOUNT_ID = os.getenv("CHATWOOT_ACCOUNT_ID")

async def crm_agent_node(state: ConversationState) -> ConversationState:
    """
    CRM Agent: Update Chatwoot contact with extracted data
    """

    print(f"üìù CRM Agent updating contact: {state['contact_id']}...")

    try:
        contact_id = state["contact_id"]
        extracted = state.get("extracted_data", {})

        # Build custom attributes
        custom_attributes = {}

        if extracted:
            if extracted.get("name"):
                custom_attributes["extracted_name"] = extracted["name"]

            if extracted.get("email"):
                custom_attributes["extracted_email"] = extracted["email"]

            if extracted.get("phone"):
                custom_attributes["extracted_phone"] = extracted["phone"]

            if extracted.get("budget_min") and extracted.get("budget_max"):
                custom_attributes["budget_range"] = f"‚Ç¨{extracted['budget_min']}-{extracted['budget_max']}"

            if extracted.get("job_type"):
                custom_attributes["job_type_preference"] = extracted["job_type"]

            if extracted.get("urgency"):
                custom_attributes["urgency_level"] = extracted["urgency"]

        # Add AI metadata
        custom_attributes["last_intent"] = state.get("intent", "unknown")
        custom_attributes["last_priority"] = state.get("priority", "medium")
        custom_attributes["last_sentiment"] = state.get("sentiment", 0.0)
        custom_attributes["ai_last_updated"] = "2025-01-15"  # Use datetime.now()

        # Generate AI summary (simple version)
        if state.get("agent_response"):
            custom_attributes["ai_summary"] = state["agent_response"][:200]

        # Update contact via Chatwoot API
        url = f"{CHATWOOT_URL}/api/v1/accounts/{CHATWOOT_ACCOUNT_ID}/contacts/{contact_id}"

        async with httpx.AsyncClient() as client:
            response = await client.put(
                url,
                headers={"api_access_token": CHATWOOT_API_TOKEN},
                json={"custom_attributes": custom_attributes}
            )

            if response.status_code == 200:
                print(f"‚úÖ Contact updated successfully")
                state["crm_updated"] = True
            else:
                print(f"‚ö†Ô∏è CRM update failed: {response.status_code}")
                state["crm_updated"] = False

        # Add labels based on intent/priority
        labels = []
        if state.get("priority") == "high":
            labels.append("high-priority")
        if state.get("intent") == "job_search":
            labels.append("job-seeker")
        if extracted and extracted.get("budget_min", 0) > 70000:
            labels.append("high-value-lead")

        if labels:
            await update_contact_labels(contact_id, labels)

    except Exception as e:
        print(f"‚ùå CRM error: {e}")
        state["error"] = str(e)
        state["crm_updated"] = False

    return state

async def update_contact_labels(contact_id: str, labels: list):
    """Add labels to Chatwoot contact"""

    url = f"{CHATWOOT_URL}/api/v1/accounts/{CHATWOOT_ACCOUNT_ID}/contacts/{contact_id}/labels"

    async with httpx.AsyncClient() as client:
        response = await client.post(
            url,
            headers={"api_access_token": CHATWOOT_API_TOKEN},
            json={"labels": labels}
        )

        if response.status_code == 200:
            print(f"‚úÖ Labels added: {labels}")
```

---

#### Day 15-16: Integration & Testing
**Task 10.1: Update FastAPI Webhook to Use LangGraph**
```python
# main.py (updated)
from fastapi import FastAPI, Request, HTTPException
from graph import conversation_app
from state import ConversationState
import httpx
import os

app = FastAPI(title="Chatwoot Webhook Service")

@app.post("/webhooks/chatwoot")
async def chatwoot_webhook(payload: dict):
    """Process Chatwoot webhooks using LangGraph"""

    print(f"üì© Received event: {payload.get('event')}")

    if payload.get("event") == "message_created":
        message = payload.get("message", {})

        # Skip outgoing messages
        if message.get("message_type") == "outgoing":
            return {"status": "skipped"}

        # Build initial state
        initial_state: ConversationState = {
            "message_id": str(message.get("id")),
            "conversation_id": str(message.get("conversation_id")),
            "contact_id": str(message.get("sender", {}).get("id")),
            "account_id": str(payload.get("account", {}).get("id")),
            "channel": "whatsapp",  # TODO: detect from inbox
            "message_content": message.get("content", ""),
            "message_type": "incoming",
            "needs_human": False,
            "retry_count": 0,
            "contact_profile": None,
            "conversation_history": None
        }

        # Run LangGraph workflow
        print("üöÄ Starting LangGraph workflow...")
        result = await conversation_app.ainvoke(initial_state)

        # Check if human needed
        if result.get("needs_human"):
            print("üë§ Human takeover required - skipping automated response")

            # TODO: Notify human agent via Chatwoot

            return {"status": "human_takeover_required", "reason": result.get("intent")}

        # Send automated response
        if result.get("agent_response"):
            await send_message_to_chatwoot(
                conversation_id=int(result["conversation_id"]),
                content=result["agent_response"]
            )

            return {"status": "processed", "response": result["agent_response"][:100]}

    return {"status": "ignored"}

async def send_message_to_chatwoot(conversation_id: int, content: str):
    """Send message back to Chatwoot"""

    url = f"{os.getenv('CHATWOOT_URL')}/api/v1/accounts/{os.getenv('CHATWOOT_ACCOUNT_ID')}/conversations/{conversation_id}/messages"

    async with httpx.AsyncClient() as client:
        response = await client.post(
            url,
            headers={"api_access_token": os.getenv("CHATWOOT_API_TOKEN")},
            json={
                "content": content,
                "message_type": "outgoing",
                "private": False
            }
        )

        if response.status_code != 200:
            raise HTTPException(500, f"Failed to send message: {response.text}")
```

**Testing Checklist**:
- [ ] Send test message: "Hi, I'm John looking for jobs"
- [ ] Router classifies as "job_search"
- [ ] Extraction captures name "John"
- [ ] Conversation generates response
- [ ] CRM updates contact in Chatwoot
- [ ] User receives response on WhatsApp
- [ ] Chatwoot contact shows custom attributes

---

### Week 3-4 Deliverables
- ‚úÖ LangGraph state machine working
- ‚úÖ 4 agents implemented and tested
- ‚úÖ End-to-end conversation flow
- ‚úÖ CRM updates persisting in Chatwoot
- ‚úÖ Human takeover logic working

### Testing Checklist (Week 3-4)
```bash
# Test Scenarios:
1. General inquiry ‚Üí Automated response
2. High priority complaint ‚Üí Human takeover
3. Job search with budget ‚Üí Data extracted, CRM updated
4. Negative sentiment ‚Üí Human takeover

‚úÖ PASS: All agents working in LangGraph workflow
```

---

## üóìÔ∏è WEEK 5: AGENTIC RAG IMPLEMENTATION

### Goals
- Populate knowledge base with documents
- Implement vector embeddings
- Add tool calling to Conversation Agent
- Agent autonomously searches when needed

### Technical Tasks

#### Day 1-2: Knowledge Base Population
**Task 11.1: Document Ingestion Script**
```python
# scripts/ingest_documents.py
from openai import AsyncOpenAI
from supabase_client import insert_document
import asyncio
from typing import List
import os

client = AsyncOpenAI(api_key=os.getenv("OPENAI_API_KEY"))

SAMPLE_DOCUMENTS = [
    {
        "content": """
        Return Policy: Customers can return products within 30 days of purchase.
        Items must be unused and in original packaging. Refunds are processed within 5-7 business days.
        Shipping costs are non-refundable unless the return is due to our error.
        """,
        "category": "policy",
        "metadata": {"title": "Return Policy", "source": "company_handbook.pdf", "page": 15}
    },
    {
        "content": """
        Current Job Openings:
        1. Senior Python Developer - Amsterdam - ‚Ç¨70-90k - Interim (6 months)
        2. DevOps Engineer - Rotterdam - ‚Ç¨65-85k - Permanent
        3. Data Scientist - Utrecht - ‚Ç¨75-95k - Freelance

        Requirements: 5+ years experience, Dutch speaking preferred.
        """,
        "category": "product",
        "metadata": {"title": "Job Vacancies", "source": "vacancies_database", "updated": "2025-01-15"}
    },
    {
        "content": """
        FAQ: How long does hiring take?

        Answer: Our typical hiring process takes 2-3 weeks:
        - Week 1: Initial screening and interviews
        - Week 2: Technical assessment and reference checks
        - Week 3: Offer and onboarding

        For interim roles, we can often place candidates within 5-7 days.
        """,
        "category": "faq",
        "metadata": {"title": "Hiring Timeline FAQ", "source": "faq_database"}
    },
    {
        "content": """
        Candidate Qualification Procedure:

        Step 1: Initial Contact - Gather name, email, phone
        Step 2: Job Preferences - Role type, location, budget
        Step 3: Experience Check - Years of experience, skills
        Step 4: Availability - Start date, contract type
        Step 5: Submission - Send relevant vacancies

        Disqualification criteria: Budget <‚Ç¨50k, less than 3 years experience.
        """,
        "category": "procedure",
        "metadata": {"title": "Qualification Procedure", "source": "internal_sop"}
    }
]

async def generate_embedding(text: str) -> List[float]:
    """Generate embedding using OpenAI"""

    response = await client.embeddings.create(
        model="text-embedding-3-small",
        input=text
    )

    return response.data[0].embedding

async def ingest_all_documents():
    """Ingest sample documents into Supabase PGVector"""

    print("üìö Starting document ingestion...")

    for doc in SAMPLE_DOCUMENTS:
        print(f"\n‚û°Ô∏è Processing: {doc['metadata']['title']}")

        # Generate embedding
        embedding = await generate_embedding(doc["content"])

        # Insert into Supabase
        result = await insert_document(
            content=doc["content"],
            embedding=embedding,
            metadata=doc["metadata"],
            category=doc["category"]
        )

        print(f"‚úÖ Inserted: ID {result['id']}")

    print("\n‚úÖ All documents ingested successfully!")

if __name__ == "__main__":
    asyncio.run(ingest_all_documents())
```

**Run ingestion**:
```bash
python scripts/ingest_documents.py
```

**Testing**:
```python
# test_vector_search.py
import asyncio
from openai import AsyncOpenAI
from supabase_client import search_documents
import os

client = AsyncOpenAI(api_key=os.getenv("OPENAI_API_KEY"))

async def test_search(query: str):
    """Test vector similarity search"""

    print(f"\nüîç Query: {query}")

    # Generate query embedding
    response = await client.embeddings.create(
        model="text-embedding-3-small",
        input=query
    )
    query_embedding = response.data[0].embedding

    # Search documents
    results = await search_documents(
        query_embedding=query_embedding,
        match_threshold=0.7,
        match_count=3
    )

    print(f"\nüìä Found {len(results)} results:")
    for i, result in enumerate(results, 1):
        print(f"\n{i}. {result['metadata']['title']} (similarity: {result['similarity']:.2f})")
        print(f"   Content: {result['content'][:100]}...")

async def run_tests():
    test_queries = [
        "What's your return policy?",
        "Are there any Python developer jobs?",
        "How long does the hiring process take?",
    ]

    for query in test_queries:
        await test_search(query)

asyncio.run(run_tests())
```

---

#### Day 3-5: Agentic RAG Implementation
**Task 12.1: Add Tool Definition to Conversation Agent**
```python
# agents/conversation_agent.py (updated)
from anthropic import AsyncAnthropic
from state import ConversationState
from openai import AsyncOpenAI
from supabase_client import search_documents
import os

anthropic_client = AsyncAnthropic(api_key=os.getenv("ANTHROPIC_API_KEY"))
openai_client = AsyncOpenAI(api_key=os.getenv("OPENAI_API_KEY"))

# Tool definition for Claude
SEARCH_KB_TOOL = {
    "name": "search_knowledge_base",
    "description": "Search company knowledge base for policies, products, FAQs, and procedures. Use this tool when the user asks factual questions about company information, job vacancies, policies, or procedures.",
    "input_schema": {
        "type": "object",
        "properties": {
            "query": {
                "type": "string",
                "description": "Search query to find relevant information"
            },
            "category": {
                "type": "string",
                "enum": ["policy", "product", "faq", "procedure"],
                "description": "Optional category filter to narrow search results"
            }
        },
        "required": ["query"]
    }
}

async def search_knowledge_base(query: str, category: str = None) -> list:
    """
    Execute knowledge base search using vector similarity.
    This function is called BY Claude when it decides to use the tool.
    """

    print(f"üîç Searching knowledge base: query='{query}', category={category}")

    # Generate query embedding
    embedding_response = await openai_client.embeddings.create(
        model="text-embedding-3-small",
        input=query
    )
    query_embedding = embedding_response.data[0].embedding

    # Search Supabase
    results = await search_documents(
        query_embedding=query_embedding,
        match_threshold=0.7,
        match_count=3,
        category=category
    )

    print(f"‚úÖ Found {len(results)} results")

    return results

CONVERSATION_SYSTEM_PROMPT = """You are a helpful recruitment assistant with access to a knowledge base.

Your capabilities:
- Answer questions about job opportunities, policies, and procedures
- Search the knowledge base when users ask factual questions
- Qualify leads for recruitment services
- Be professional, friendly, and concise

When to use search_knowledge_base tool:
- User asks about company policies (returns, refunds, terms)
- User asks about job vacancies or openings
- User asks "how long does X take" (procedures)
- User asks FAQ-type questions

When NOT to search:
- Greetings ("Hello", "Hi")
- Small talk
- Questions about the user themselves
- Questions you can answer from context

Guidelines:
- Keep responses under 200 words
- Cite information from knowledge base when used
- Ask clarifying questions when needed
- If you don't know, say so politely
"""

async def conversation_agent_node(state: ConversationState) -> ConversationState:
    """
    Conversation Agent: Generate responses with Agentic RAG
    Model: Claude 3.5 Sonnet with tool calling
    """

    print(f"üí¨ Conversation Agent (Agentic RAG) processing...")

    try:
        # Build context
        context = f"""
User message: {state['message_content']}
Intent: {state.get('intent', 'unknown')}
Priority: {state.get('priority', 'medium')}
Extracted data: {state.get('extracted_data', {})}
        """

        # Initial call with tools available
        response = await anthropic_client.messages.create(
            model="claude-3-5-sonnet-20241022",
            max_tokens=1024,
            system=CONVERSATION_SYSTEM_PROMPT,
            messages=[
                {"role": "user", "content": context}
            ],
            tools=[SEARCH_KB_TOOL]  # Agent CAN use, not forced!
        )

        # Check if agent decided to use tool
        if response.stop_reason == "tool_use":
            print("üîß Agent decided to search knowledge base")

            # Extract tool use
            tool_use = None
            for content_block in response.content:
                if content_block.type == "tool_use":
                    tool_use = content_block
                    break

            if tool_use and tool_use.name == "search_knowledge_base":
                # Execute search
                search_results = await search_knowledge_base(
                    query=tool_use.input["query"],
                    category=tool_use.input.get("category")
                )

                # Store RAG results in state
                state["rag_results"] = search_results

                # Format results for Claude
                formatted_results = "\n\n".join([
                    f"Document {i+1}: {r['metadata']['title']}\n{r['content']}"
                    for i, r in enumerate(search_results)
                ])

                # Continue conversation with search results
                final_response = await anthropic_client.messages.create(
                    model="claude-3-5-sonnet-20241022",
                    max_tokens=1024,
                    system=CONVERSATION_SYSTEM_PROMPT,
                    messages=[
                        {"role": "user", "content": context},
                        {"role": "assistant", "content": response.content},
                        {
                            "role": "user",
                            "content": [
                                {
                                    "type": "tool_result",
                                    "tool_use_id": tool_use.id,
                                    "content": formatted_results
                                }
                            ]
                        }
                    ]
                )

                # Extract final text response
                agent_response = ""
                for content_block in final_response.content:
                    if content_block.type == "text":
                        agent_response += content_block.text

                state["agent_response"] = agent_response
                print(f"‚úÖ Response with RAG: {agent_response[:100]}...")

        else:
            # Agent responded directly without search
            print("üí¨ Direct response (no RAG needed)")

            agent_response = ""
            for content_block in response.content:
                if content_block.type == "text":
                    agent_response += content_block.text

            state["agent_response"] = agent_response
            print(f"‚úÖ Response: {agent_response[:100]}...")

    except Exception as e:
        print(f"‚ùå Conversation error: {e}")
        state["error"] = str(e)
        state["agent_response"] = "I apologize, I'm having trouble processing your request."
        state["needs_human"] = True

    return state
```

**Testing Checklist**:
- [ ] Query: "What's your return policy?" ‚Üí Agent searches KB
- [ ] Query: "Hello!" ‚Üí Agent responds directly (no search)
- [ ] Query: "Are there Python jobs?" ‚Üí Agent searches KB
- [ ] RAG results stored in state
- [ ] Response includes information from KB

---

### Week 5 Deliverables
- ‚úÖ Knowledge base populated with documents
- ‚úÖ Vector embeddings generated
- ‚úÖ Agentic RAG working (agent decides when to search)
- ‚úÖ Search results integrated into responses
- ‚úÖ No unnecessary searches (efficient)

### Testing Checklist (Week 5)
```bash
# Test Agentic RAG:
1. "What's your return policy?" ‚Üí Searches KB, cites policy
2. "Hello, how are you?" ‚Üí Direct response, no search
3. "Any DevOps jobs available?" ‚Üí Searches vacancies
4. "How long does hiring take?" ‚Üí Searches FAQ

‚úÖ PASS: Agent autonomously decides when to search
```

---

## üóìÔ∏è WEEK 6: CRM INTEGRATION & HUMAN TAKEOVER

### Goals
- Configure custom attributes in Chatwoot
- Implement AI summaries
- Build human takeover workflow
- Test multi-channel messaging

### Technical Tasks

#### Day 1-2: Custom Attributes Configuration
**Task 13.1: Define Custom Attributes in Chatwoot**
```bash
# In Chatwoot UI:
# Settings ‚Üí Custom Attributes ‚Üí Contacts ‚Üí Add Attribute

# Add these custom attributes:
1. extracted_name (Text)
2. extracted_email (Text)
3. extracted_phone (Text)
4. budget_range (Text)
5. job_type_preference (List: interim, permanent, freelance)
6. urgency_level (List: high, medium, low)
7. last_intent (Text)
8. last_priority (List: high, medium, low)
9. last_sentiment (Number: -1.0 to 1.0)
10. ai_summary (Text - Long)
11. lead_status (List: new, qualified, unqualified, contacted)
12. lead_source (Text)
13. instagram_handle (Text)
14. follower_count (Number)
```

**Task 13.2: Enhanced CRM Agent**
```python
# agents/crm_agent.py (enhanced)
from openai import AsyncOpenAI
import httpx
import os

openai_client = AsyncOpenAI(api_key=os.getenv("OPENAI_API_KEY"))

async def generate_ai_summary(state: dict) -> str:
    """Generate AI summary of conversation for CRM"""

    summary_prompt = f"""Generate a concise CRM summary (max 100 words) of this conversation:

Message: {state['message_content']}
Intent: {state.get('intent')}
Extracted data: {state.get('extracted_data')}
Agent response: {state.get('agent_response')}

Focus on:
- User's needs/goals
- Key information provided
- Next steps needed
- Lead quality assessment
"""

    response = await openai_client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[{"role": "user", "content": summary_prompt}],
        max_tokens=150,
        temperature=0.5
    )

    return response.choices[0].message.content

async def determine_lead_status(extracted: dict) -> str:
    """Determine lead status based on extracted data"""

    # Qualified if:
    # - Has budget > ‚Ç¨50k
    # - Has specific job type
    # - High urgency

    if not extracted:
        return "new"

    budget_min = extracted.get("budget_min", 0)
    has_job_type = extracted.get("job_type") is not None
    urgency = extracted.get("urgency", "low")

    if budget_min >= 50000 and has_job_type and urgency == "high":
        return "qualified"
    elif budget_min > 0 and has_job_type:
        return "qualified"
    elif budget_min > 0 or has_job_type:
        return "contacted"
    else:
        return "new"

async def crm_agent_node(state: dict) -> dict:
    """Enhanced CRM Agent with AI summaries"""

    print(f"üìù CRM Agent updating contact...")

    try:
        contact_id = state["contact_id"]
        extracted = state.get("extracted_data", {})

        # Generate AI summary
        ai_summary = await generate_ai_summary(state)

        # Determine lead status
        lead_status = await determine_lead_status(extracted)

        # Build custom attributes
        custom_attributes = {
            "ai_summary": ai_summary,
            "lead_status": lead_status,
            "last_intent": state.get("intent", "unknown"),
            "last_priority": state.get("priority", "medium"),
            "last_sentiment": state.get("sentiment", 0.0),
            "ai_last_updated": "2025-01-15"
        }

        # Add extracted data if present
        if extracted:
            if extracted.get("name"):
                custom_attributes["extracted_name"] = extracted["name"]
            if extracted.get("email"):
                custom_attributes["extracted_email"] = extracted["email"]
            if extracted.get("phone"):
                custom_attributes["extracted_phone"] = extracted["phone"]
            if extracted.get("budget_min") and extracted.get("budget_max"):
                custom_attributes["budget_range"] = f"‚Ç¨{extracted['budget_min']}-{extracted['budget_max']}"
            if extracted.get("job_type"):
                custom_attributes["job_type_preference"] = extracted["job_type"]
            if extracted.get("urgency"):
                custom_attributes["urgency_level"] = extracted["urgency"]

        # Update contact
        url = f"{os.getenv('CHATWOOT_URL')}/api/v1/accounts/{os.getenv('CHATWOOT_ACCOUNT_ID')}/contacts/{contact_id}"

        async with httpx.AsyncClient() as client:
            response = await client.put(
                url,
                headers={"api_access_token": os.getenv("CHATWOOT_API_TOKEN")},
                json={"custom_attributes": custom_attributes}
            )

            if response.status_code == 200:
                print(f"‚úÖ Contact updated with AI summary")
                state["crm_updated"] = True
            else:
                print(f"‚ö†Ô∏è CRM update failed: {response.status_code}")
                state["crm_updated"] = False

        # Add labels
        labels = []
        if state.get("priority") == "high":
            labels.append("high-priority")
        if state.get("intent") == "job_search":
            labels.append("job-seeker")
        if lead_status == "qualified":
            labels.append("qualified-lead")
        if extracted and extracted.get("budget_min", 0) > 70000:
            labels.append("high-value-lead")

        if labels:
            await update_contact_labels(contact_id, labels)

    except Exception as e:
        print(f"‚ùå CRM error: {e}")
        state["crm_updated"] = False

    return state

async def update_contact_labels(contact_id: str, labels: list):
    """Add labels to contact"""

    url = f"{os.getenv('CHATWOOT_URL')}/api/v1/accounts/{os.getenv('CHATWOOT_ACCOUNT_ID')}/contacts/{contact_id}/labels"

    async with httpx.AsyncClient() as client:
        response = await client.post(
            url,
            headers={"api_access_token": os.getenv("CHATWOOT_API_TOKEN")},
            json={"labels": labels}
        )

        if response.status_code == 200:
            print(f"‚úÖ Labels added: {labels}")
```

---

#### Day 3-4: Human Takeover Implementation
**Task 14.1: Human Takeover Notification**
```python
# agents/human_takeover.py
import httpx
import os

async def notify_human_agent(state: dict):
    """
    Notify human agent of takeover needed.
    Methods:
    1. Add private note in Chatwoot
    2. Assign conversation to human agent
    3. Change conversation status to 'open'
    """

    print(f"üë§ Notifying human agent for conversation {state['conversation_id']}")

    conversation_id = state["conversation_id"]

    # 1. Add private note
    note_content = f"""
ü§ñ AI Agent requires human assistance:

**Reason**: {state.get('intent', 'unknown intent')} (Priority: {state.get('priority', 'medium')})

**Context**:
- Message: {state['message_content'][:200]}
- Sentiment: {state.get('sentiment', 0.0)}
- Extracted data: {state.get('extracted_data')}

**AI Assessment**:
{state.get('agent_response', 'No automated response generated')}

Please review and respond manually.
    """

    url = f"{os.getenv('CHATWOOT_URL')}/api/v1/accounts/{os.getenv('CHATWOOT_ACCOUNT_ID')}/conversations/{conversation_id}/messages"

    async with httpx.AsyncClient() as client:
        # Add private note
        await client.post(
            url,
            headers={"api_access_token": os.getenv("CHATWOOT_API_TOKEN")},
            json={
                "content": note_content,
                "message_type": "outgoing",
                "private": True  # Only visible to agents
            }
        )

        # Update conversation status to 'open'
        await client.post(
            f"{os.getenv('CHATWOOT_URL')}/api/v1/accounts/{os.getenv('CHATWOOT_ACCOUNT_ID')}/conversations/{conversation_id}/toggle_status",
            headers={"api_access_token": os.getenv("CHATWOOT_API_TOKEN")},
            json={"status": "open"}
        )

        # Add label for human review
        await client.post(
            f"{os.getenv('CHATWOOT_URL')}/api/v1/accounts/{os.getenv('CHATWOOT_ACCOUNT_ID')}/conversations/{conversation_id}/labels",
            headers={"api_access_token": os.getenv("CHATWOOT_API_TOKEN")},
            json={"labels": ["needs-human-review"]}
        )

    print("‚úÖ Human agent notified")
```

**Task 14.2: Update Webhook Handler**
```python
# main.py (updated human takeover section)
@app.post("/webhooks/chatwoot")
async def chatwoot_webhook(payload: dict):
    """Process webhooks with human takeover support"""

    # ... (existing code) ...

    # Run LangGraph workflow
    result = await conversation_app.ainvoke(initial_state)

    # Check if human needed
    if result.get("needs_human"):
        print("üë§ Human takeover required")

        # Notify human agent
        await notify_human_agent(result)

        # Send acknowledgment to user
        await send_message_to_chatwoot(
            conversation_id=int(result["conversation_id"]),
            content="Thank you for your message. A human agent will respond shortly."
        )

        return {"status": "human_takeover_initiated"}

    # ... (existing automated response code) ...
```

---

#### Day 5-6: Multi-Channel Testing
**Task 15.1: Instagram Integration (Optional)**
```bash
# In Chatwoot UI:
# Settings ‚Üí Inboxes ‚Üí Add Inbox ‚Üí Instagram

# Requirements:
# 1. Facebook Business Account
# 2. Instagram Business Profile
# 3. Meta Graph API access

# Configuration:
# - Connect Instagram account
# - Webhook URL: https://your-app.railway.app/webhooks/instagram
# - Permissions: instagram_manage_messages, instagram_basic
```

**Task 15.2: Email Integration**
```bash
# In Chatwoot UI:
# Settings ‚Üí Inboxes ‚Üí Add Inbox ‚Üí Email

# Configuration:
# - Email: support@yourcompany.com
# - IMAP: imap.gmail.com:993 (SSL)
# - SMTP: smtp.gmail.com:587 (TLS)
# - Credentials: email + app password
```

**Testing Checklist**:
- [ ] WhatsApp message processed correctly
- [ ] Instagram DM processed (if configured)
- [ ] Email processed (if configured)
- [ ] CRM updates work across all channels
- [ ] Human takeover works for all channels

---

### Week 6 Deliverables
- ‚úÖ Custom attributes configured in Chatwoot
- ‚úÖ AI summaries generated and stored
- ‚úÖ Lead status classification working
- ‚úÖ Human takeover workflow implemented
- ‚úÖ Private notes added for human agents
- ‚úÖ Multi-channel messaging tested

### Testing Checklist (Week 6)
```bash
# Test Human Takeover:
1. Send complaint: "This is terrible service!" ‚Üí Human notified
2. Check Chatwoot: Private note visible, status = 'open'
3. Human replies ‚Üí User receives response
4. AI stops intervening

# Test CRM:
1. Send message with budget info
2. Check Chatwoot contact profile
3. Verify: AI summary, lead status, custom attributes

‚úÖ PASS: CRM and human takeover working
```

---

## üóìÔ∏è WEEK 7: PRODUCTION SERVICES

### Goals
- Integrate 360Dialog for production WhatsApp
- Implement ScrapeCreators lead import
- Add rate limiting
- GDPR compliance measures

### Technical Tasks

#### Day 1-3: 360Dialog Integration
**Task 16.1: Setup 360Dialog Account**
```bash
# 1. Sign up at https://www.360dialog.com
# 2. Verify business
# 3. Get API key
# 4. Register phone number
# 5. Configure webhook
```

**Task 16.2: 360Dialog Chatwoot Integration**
```bash
# In Chatwoot UI:
# Settings ‚Üí Inboxes ‚Üí Add Inbox ‚Üí WhatsApp
# Select: 360Dialog

# Configuration:
# - API Key: (from 360Dialog dashboard)
# - Phone Number ID: (from 360Dialog)
# - Webhook URL: https://your-chatwoot.railway.app/webhooks/360dialog
```

**Task 16.3: 360Dialog Webhook Handler**
```python
# main.py (add 360Dialog webhook)
@app.post("/webhooks/360dialog")
async def dialog_360_webhook(payload: dict):
    """
    Receive webhooks from 360Dialog and forward to Chatwoot.

    360Dialog ‚Üí FastAPI ‚Üí Chatwoot ‚Üí LangGraph
    """

    print(f"üì± 360Dialog webhook received")

    # Verify webhook (360Dialog specific)
    if payload.get("entry"):
        for entry in payload["entry"]:
            for change in entry.get("changes", []):
                if change.get("value", {}).get("messages"):
                    for message in change["value"]["messages"]:
                        # Forward to Chatwoot inbox
                        await forward_to_chatwoot(message)

    return {"status": "ok"}

async def forward_to_chatwoot(message: dict):
    """Forward 360Dialog message to Chatwoot"""

    # Extract message data
    from_number = message.get("from")
    text = message.get("text", {}).get("body", "")
    message_id = message.get("id")

    # Create or get contact in Chatwoot
    contact = await get_or_create_contact(from_number)

    # Create message in Chatwoot
    url = f"{os.getenv('CHATWOOT_URL')}/api/v1/accounts/{os.getenv('CHATWOOT_ACCOUNT_ID')}/contacts/{contact['id']}/conversations"

    async with httpx.AsyncClient() as client:
        response = await client.post(
            url,
            headers={"api_access_token": os.getenv("CHATWOOT_API_TOKEN")},
            json={
                "inbox_id": os.getenv("CHATWOOT_360DIALOG_INBOX_ID"),
                "message": text,
                "source_id": message_id
            }
        )

    # This triggers Chatwoot webhook ‚Üí LangGraph workflow
```

**Testing Checklist**:
- [ ] 360Dialog account set up
- [ ] Phone number registered
- [ ] Webhook receiving messages
- [ ] Messages forwarded to Chatwoot
- [ ] LangGraph processes 360Dialog messages

---

#### Day 4-5: ScrapeCreators Integration
**Task 17.1: CSV Import Script**
```python
# scripts/import_scrape_creators.py
import csv
import httpx
import asyncio
from typing import List, Dict

CHATWOOT_URL = os.getenv("CHATWOOT_URL")
CHATWOOT_API_TOKEN = os.getenv("CHATWOOT_API_TOKEN")
ACCOUNT_ID = os.getenv("CHATWOOT_ACCOUNT_ID")

async def import_scraped_leads(csv_file: str) -> None:
    """
    Import leads from ScrapeCreators CSV to Chatwoot.

    CSV Format:
    name, username, email, whatsapp, bio, followers, niche
    """

    print(f"üì• Importing leads from {csv_file}...")

    imported = 0
    errors = 0

    with open(csv_file, 'r', encoding='utf-8') as f:
        reader = csv.DictReader(f)

        for row in reader:
            try:
                # Create contact
                contact = await create_contact_from_scrape(row)

                if contact:
                    imported += 1
                    print(f"‚úÖ Imported: {row['name']} (@{row['username']})")

                    # Rate limiting: 1 contact per second (avoid API throttle)
                    await asyncio.sleep(1)
                else:
                    errors += 1

            except Exception as e:
                print(f"‚ùå Error importing {row['name']}: {e}")
                errors += 1

    print(f"\nüìä Import complete: {imported} imported, {errors} errors")

async def create_contact_from_scrape(row: Dict) -> Dict:
    """Create Chatwoot contact from scraped data"""

    async with httpx.AsyncClient() as client:
        # Check if contact already exists
        existing = await client.get(
            f"{CHATWOOT_URL}/api/v1/accounts/{ACCOUNT_ID}/contacts/search",
            headers={"api_access_token": CHATWOOT_API_TOKEN},
            params={"q": row['username']}
        )

        if existing.json()["payload"]:
            print(f"‚è≠Ô∏è Contact already exists: {row['username']}")
            return None

        # Create contact
        response = await client.post(
            f"{CHATWOOT_URL}/api/v1/accounts/{ACCOUNT_ID}/contacts",
            headers={"api_access_token": CHATWOOT_API_TOKEN},
            json={
                "name": row['name'],
                "email": row.get('email', ''),
                "phone_number": row.get('whatsapp', ''),
                "custom_attributes": {
                    "lead_source": "instagram_scrape",
                    "instagram_handle": row['username'],
                    "follower_count": int(row.get('followers', 0)),
                    "bio": row.get('bio', ''),
                    "niche": row.get('niche', ''),
                    "scraped_date": "2025-01-15",  # Use datetime.now()
                    "lead_status": "new",
                    "outreach_status": "pending"
                }
            }
        )

        if response.status_code != 200:
            raise Exception(f"API error: {response.status_code}")

        contact_id = response.json()['payload']['contact']['id']

        # Add labels
        await client.post(
            f"{CHATWOOT_URL}/api/v1/accounts/{ACCOUNT_ID}/contacts/{contact_id}/labels",
            headers={"api_access_token": CHATWOOT_API_TOKEN},
            json={"labels": ["scraped-lead", "cold-outreach", "instagram"]}
        )

        return response.json()['payload']['contact']

# Usage
if __name__ == "__main__":
    import sys

    if len(sys.argv) < 2:
        print("Usage: python import_scrape_creators.py leads.csv")
        sys.exit(1)

    asyncio.run(import_scraped_leads(sys.argv[1]))
```

**Run import**:
```bash
python scripts/import_scrape_creators.py leads.csv
```

---

#### Day 6: Rate Limiting
**Task 18.1: Implement Rate Limiting**
```python
# middleware/rate_limiter.py
from fastapi import Request, HTTPException
from collections import defaultdict
from datetime import datetime, timedelta
import asyncio

class RateLimiter:
    """Simple rate limiter using in-memory storage"""

    def __init__(self, max_requests: int = 50, window_seconds: int = 3600):
        self.max_requests = max_requests
        self.window_seconds = window_seconds
        self.requests = defaultdict(list)  # {contact_id: [timestamp1, timestamp2, ...]}

    async def check_limit(self, contact_id: str) -> bool:
        """Check if contact has exceeded rate limit"""

        now = datetime.now()
        window_start = now - timedelta(seconds=self.window_seconds)

        # Clean old requests
        self.requests[contact_id] = [
            ts for ts in self.requests[contact_id]
            if ts > window_start
        ]

        # Check limit
        if len(self.requests[contact_id]) >= self.max_requests:
            return False  # Rate limit exceeded

        # Add current request
        self.requests[contact_id].append(now)

        return True  # Within limit

# Initialize rate limiter
rate_limiter = RateLimiter(max_requests=50, window_seconds=3600)  # 50 messages/hour

# Use in webhook handler
@app.post("/webhooks/chatwoot")
async def chatwoot_webhook(payload: dict):
    # ... (existing code) ...

    contact_id = str(message.get("sender", {}).get("id"))

    # Check rate limit
    if not await rate_limiter.check_limit(contact_id):
        print(f"‚ö†Ô∏è Rate limit exceeded for contact {contact_id}")

        # Send rate limit message
        await send_message_to_chatwoot(
            conversation_id=int(message["conversation_id"]),
            content="You've reached the message limit. Please try again later or contact support."
        )

        return {"status": "rate_limited"}

    # ... (continue with LangGraph) ...
```

---

#### Day 7: GDPR Compliance
**Task 19.1: Privacy Policy & Consent**
```python
# agents/gdpr_compliance.py
async def check_consent(contact_id: str) -> bool:
    """Check if contact has given GDPR consent"""

    # Query Chatwoot for consent attribute
    contact = await get_chatwoot_contact(contact_id)

    return contact.get("custom_attributes", {}).get("gdpr_consent", False)

async def request_consent(conversation_id: str):
    """Request GDPR consent from user"""

    consent_message = """
Before we continue, we need your consent to process your personal data.

We collect:
- Name, email, phone
- Job preferences and budget
- Conversation history

Your data is used for:
- Matching you with job opportunities
- Providing recruitment services
- Improving our service

You can request deletion anytime by replying "DELETE MY DATA".

Reply "I AGREE" to continue.

Privacy Policy: https://yourcompany.com/privacy
    """

    await send_message_to_chatwoot(conversation_id, consent_message)

# Add to conversation flow
async def conversation_agent_node(state: dict) -> dict:
    """Conversation agent with GDPR check"""

    # Check consent
    has_consent = await check_consent(state["contact_id"])

    if not has_consent:
        # First message: Request consent
        await request_consent(state["conversation_id"])

        # Wait for user response
        state["agent_response"] = None  # Don't send automated response yet
        state["needs_human"] = True  # Let human verify consent

        return state

    # ... (continue with normal conversation) ...
```

**Task 19.2: Data Deletion Endpoint**
```python
# main.py
@app.post("/api/gdpr/delete")
async def gdpr_delete_request(contact_id: str):
    """
    Handle GDPR data deletion requests.

    Required by GDPR: Must delete within 30 days.
    """

    print(f"üóëÔ∏è GDPR deletion request for contact {contact_id}")

    # 1. Delete from Chatwoot
    async with httpx.AsyncClient() as client:
        await client.delete(
            f"{os.getenv('CHATWOOT_URL')}/api/v1/accounts/{os.getenv('CHATWOOT_ACCOUNT_ID')}/contacts/{contact_id}",
            headers={"api_access_token": os.getenv("CHATWOOT_API_TOKEN")}
        )

    # 2. Log deletion for compliance
    with open("gdpr_deletions.log", "a") as f:
        f.write(f"{datetime.now().isoformat()}: Contact {contact_id} deleted\n")

    return {"status": "deleted", "contact_id": contact_id}
```

---

### Week 7 Deliverables
- ‚úÖ 360Dialog production WhatsApp working
- ‚úÖ ScrapeCreators CSV import script
- ‚úÖ Rate limiting implemented (50 msg/hour)
- ‚úÖ GDPR consent flow
- ‚úÖ Data deletion endpoint

### Testing Checklist (Week 7)
```bash
# Test 360Dialog:
1. Send WhatsApp to production number
2. Message appears in Chatwoot
3. LangGraph processes correctly
4. Response delivered via 360Dialog

# Test Import:
1. Run: python import_scrape_creators.py test.csv
2. Check Chatwoot: Contacts imported
3. Verify: Custom attributes, labels

# Test Rate Limit:
1. Send 51 messages rapidly
2. 51st message: Rate limit response

‚úÖ PASS: Production services working
```

---

## üóìÔ∏è WEEK 8: WHITE-LABEL & DEPLOYMENT

### Goals
- Apply white-label branding
- End-to-end testing
- Performance optimization
- Production deployment

### Technical Tasks

#### Day 1-2: White-Label Branding
**Task 20.1: Custom Branding Configuration**
```yaml
# docker-compose.yml (per-client configuration)
version: '3'

services:
  chatwoot:
    image: chatwoot/chatwoot:latest
    environment:
      # Core
      RAILS_ENV: production
      SECRET_KEY_BASE: ${SECRET_KEY_BASE}

      # Database
      DATABASE_URL: ${DATABASE_URL}
      REDIS_URL: ${REDIS_URL}

      # White-label branding
      BRAND_NAME: "RecruitmentPro CRM"
      FRONTEND_URL: "https://client1.yourcompany.com"
      LOGO_THUMBNAIL: "https://cdn.yourcompany.com/client1/logo-small.png"
      LOGO: "https://cdn.yourcompany.com/client1/logo-large.png"
      WIDGET_BRAND_URL: ""  # Removes "Powered by Chatwoot"

      # Colors
      PRIMARY_COLOR: "#1f93ff"

    ports:
      - "3000:3000"
    depends_on:
      - postgres
      - redis

  postgres:
    image: postgres:14
    environment:
      POSTGRES_DB: chatwoot_production
      POSTGRES_USER: chatwoot
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
```

**Task 20.2: Custom CSS**
```css
/* custom-branding.css */
:root {
  --color-primary: #1f93ff;
  --color-primary-dark: #1a7dd9;
  --color-secondary: #6c757d;
}

/* Logo customization */
.app-logo {
  content: url('https://cdn.yourcompany.com/client1/logo.png');
}

/* Hide "Powered by Chatwoot" */
.branding-footer {
  display: none !important;
}

/* Custom colors */
.button--primary {
  background-color: var(--color-primary);
}

.conversation-sidebar {
  border-left-color: var(--color-primary);
}
```

**Deploy per client**:
```bash
# Client 1
docker-compose -f docker-compose.client1.yml up -d

# Client 2
docker-compose -f docker-compose.client2.yml up -d

# Each gets own:
# - Database
# - Chatwoot instance
# - Subdomain (client1.yourcompany.com)
# - Branding
```

---

#### Day 3-4: End-to-End Testing
**Task 21.1: Integration Test Suite**
```python
# tests/test_integration.py
import pytest
import httpx
import asyncio

@pytest.mark.asyncio
async def test_full_conversation_flow():
    """Test complete conversation flow: WhatsApp ‚Üí Chatwoot ‚Üí LangGraph ‚Üí Response"""

    # 1. Send message to webhook (simulating Chatwoot)
    webhook_payload = {
        "event": "message_created",
        "account": {"id": 1},
        "message": {
            "id": 123,
            "content": "Hi, I'm looking for Python developer jobs, budget ‚Ç¨70-90k",
            "message_type": "incoming",
            "conversation_id": 456,
            "sender": {"id": 789}
        }
    }

    async with httpx.AsyncClient() as client:
        response = await client.post(
            "http://localhost:8000/webhooks/chatwoot",
            json=webhook_payload
        )

        assert response.status_code == 200
        assert response.json()["status"] == "processed"

    # 2. Verify CRM updated
    await asyncio.sleep(2)  # Wait for async processing

    # TODO: Query Chatwoot API to verify contact attributes

    # 3. Verify response sent
    # TODO: Check Chatwoot conversation for agent response

@pytest.mark.asyncio
async def test_agentic_rag_search():
    """Test that agent searches knowledge base when appropriate"""

    webhook_payload = {
        "event": "message_created",
        "account": {"id": 1},
        "message": {
            "id": 124,
            "content": "What's your return policy?",
            "message_type": "incoming",
            "conversation_id": 457,
            "sender": {"id": 790}
        }
    }

    async with httpx.AsyncClient() as client:
        response = await client.post(
            "http://localhost:8000/webhooks/chatwoot",
            json=webhook_payload
        )

        assert response.status_code == 200
        # TODO: Verify agent response contains policy information

@pytest.mark.asyncio
async def test_human_takeover():
    """Test human takeover for complaints"""

    webhook_payload = {
        "event": "message_created",
        "account": {"id": 1},
        "message": {
            "id": 125,
            "content": "This is terrible service! I want a refund!",
            "message_type": "incoming",
            "conversation_id": 458,
            "sender": {"id": 791}
        }
    }

    async with httpx.AsyncClient() as client:
        response = await client.post(
            "http://localhost:8000/webhooks/chatwoot",
            json=webhook_payload
        )

        assert response.status_code == 200
        assert "human_takeover" in response.json()["status"]

# Run tests
# pytest tests/test_integration.py -v
```

---

#### Day 5: Performance Optimization
**Task 22.1: Add Caching**
```python
# middleware/cache.py
from functools import lru_cache
import hashlib
import json

@lru_cache(maxsize=100)
async def cached_vector_search(query_hash: str):
    """Cache vector search results"""
    # Implement caching for common queries
    pass

# Use in conversation agent
async def search_knowledge_base(query: str, category: str = None) -> list:
    """Search with caching"""

    # Create cache key
    cache_key = hashlib.md5(f"{query}:{category}".encode()).hexdigest()

    # Check cache
    cached = await get_from_cache(cache_key)
    if cached:
        print("‚úÖ Cache hit")
        return cached

    # Execute search
    results = await _execute_search(query, category)

    # Store in cache (5 minute TTL)
    await store_in_cache(cache_key, results, ttl=300)

    return results
```

**Task 22.2: Database Connection Pooling**
```python
# database/connection.py
from sqlalchemy import create_engine
from sqlalchemy.pool import QueuePool

engine = create_engine(
    os.getenv("DATABASE_URL"),
    poolclass=QueuePool,
    pool_size=10,
    max_overflow=20,
    pool_timeout=30,
    pool_recycle=3600
)
```

---

#### Day 6-7: Production Deployment
**Task 23.1: Railway Deployment**
```bash
# Deploy FastAPI service
cd chatwoot-webhook-service
railway init
railway link
railway add --plugin redis  # For caching
railway up

# Set environment variables
railway variables set OPENAI_API_KEY=xxx
railway variables set ANTHROPIC_API_KEY=xxx
railway variables set CHATWOOT_URL=xxx
railway variables set CHATWOOT_API_TOKEN=xxx
railway variables set SUPABASE_URL=xxx
railway variables set SUPABASE_SERVICE_KEY=xxx

# Deploy Chatwoot
cd ../chatwoot
railway up

# Configure custom domain
railway domain add client1.yourcompany.com
```

**Task 23.2: Monitoring Setup**
```python
# monitoring/health.py
from fastapi import FastAPI
from prometheus_client import Counter, Histogram, generate_latest

app = FastAPI()

# Metrics
messages_processed = Counter('messages_processed_total', 'Total messages processed')
processing_time = Histogram('processing_time_seconds', 'Message processing time')
errors = Counter('errors_total', 'Total errors', ['type'])

@app.get("/metrics")
async def metrics():
    """Prometheus metrics endpoint"""
    return generate_latest()

@app.get("/health")
async def health():
    """Health check endpoint"""

    # Check database connection
    # Check Supabase connection
    # Check API keys

    return {
        "status": "healthy",
        "version": "1.0",
        "services": {
            "database": "ok",
            "supabase": "ok",
            "openai": "ok",
            "anthropic": "ok"
        }
    }
```

---

### Week 8 Deliverables
- ‚úÖ White-label branding applied
- ‚úÖ Per-client Docker Compose configs
- ‚úÖ End-to-end tests passing
- ‚úÖ Performance optimizations implemented
- ‚úÖ Production deployment complete
- ‚úÖ Monitoring active

### Final Testing Checklist (Week 8)
```bash
# Production Smoke Tests:
1. WhatsApp ‚Üí Chatwoot ‚Üí LangGraph ‚Üí Response ‚úÖ
2. RAG search working ‚úÖ
3. CRM updates persisting ‚úÖ
4. Human takeover triggers correctly ‚úÖ
5. Rate limiting active ‚úÖ
6. GDPR compliance working ‚úÖ
7. White-label branding visible ‚úÖ
8. 360Dialog production WhatsApp ‚úÖ
9. Monitoring dashboards live ‚úÖ
10. Performance <3s response time ‚úÖ

üöÄ READY FOR PRODUCTION!
```

---

## üìö DEVELOPMENT ENVIRONMENT SETUP

### Local Docker Compose (All Services)
```yaml
# docker-compose.dev.yml
version: '3'

services:
  chatwoot:
    image: chatwoot/chatwoot:latest
    environment:
      RAILS_ENV: development
      DATABASE_URL: postgres://postgres:password@postgres:5432/chatwoot_dev
      REDIS_URL: redis://redis:6379
    ports:
      - "3000:3000"
    depends_on:
      - postgres
      - redis

  postgres:
    image: postgres:14
    environment:
      POSTGRES_DB: chatwoot_dev
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

  fastapi:
    build: ./chatwoot-webhook-service
    environment:
      CHATWOOT_URL: http://chatwoot:3000
      CHATWOOT_API_TOKEN: ${CHATWOOT_API_TOKEN}
      OPENAI_API_KEY: ${OPENAI_API_KEY}
      ANTHROPIC_API_KEY: ${ANTHROPIC_API_KEY}
      SUPABASE_URL: ${SUPABASE_URL}
      SUPABASE_SERVICE_KEY: ${SUPABASE_SERVICE_KEY}
    ports:
      - "8000:8000"
    volumes:
      - ./chatwoot-webhook-service:/app
    depends_on:
      - chatwoot

volumes:
  postgres_data:
```

**Start local environment**:
```bash
docker-compose -f docker-compose.dev.yml up -d
```

---

## üß™ TESTING STRATEGY

### Unit Tests (Business Logic)
```python
# tests/unit/test_agents.py
import pytest
from agents.router_agent import router_agent_node
from state import ConversationState

@pytest.mark.asyncio
async def test_router_classifies_job_search():
    state = {
        "message_content": "Looking for Python developer jobs",
        "message_id": "test",
        "conversation_id": "test",
        "contact_id": "test",
        "account_id": "1",
        "channel": "whatsapp",
        "message_type": "incoming",
        "needs_human": False,
        "retry_count": 0
    }

    result = await router_agent_node(state)

    assert result["intent"] == "job_search"
    assert result["priority"] in ["medium", "low"]

# Run: pytest tests/unit/ -v
```

### Integration Tests (API Endpoints)
```python
# tests/integration/test_webhook.py
import pytest
import httpx

@pytest.mark.asyncio
async def test_chatwoot_webhook_endpoint():
    async with httpx.AsyncClient() as client:
        response = await client.post(
            "http://localhost:8000/webhooks/chatwoot",
            json={"event": "message_created", "message": {...}}
        )

        assert response.status_code == 200

# Run: pytest tests/integration/ -v
```

### End-to-End Tests
```bash
# tests/e2e/test_full_flow.sh
#!/bin/bash

# 1. Send WhatsApp message
curl -X POST http://localhost:8000/webhooks/chatwoot -d '...'

# 2. Wait for processing
sleep 3

# 3. Check Chatwoot for response
curl http://localhost:3000/api/v1/conversations/123

# 4. Verify CRM updated
curl http://localhost:3000/api/v1/contacts/456
```

---

## üöÄ DEPLOYMENT GUIDE

### Railway Deployment Steps
```bash
# 1. Install Railway CLI
npm install -g @railway/cli

# 2. Login
railway login

# 3. Initialize project
railway init

# 4. Add services
railway add --plugin postgresql
railway add --plugin redis

# 5. Deploy Chatwoot
railway up

# 6. Deploy FastAPI
cd chatwoot-webhook-service
railway up

# 7. Set environment variables
railway variables set OPENAI_API_KEY=xxx
railway variables set ANTHROPIC_API_KEY=xxx
...

# 8. Configure custom domain
railway domain add app.yourcompany.com

# 9. Enable automatic deployments
railway link <github-repo>
```

### Environment Variables Checklist
```bash
# Required for production:
CHATWOOT_URL=https://app.yourcompany.com
CHATWOOT_API_TOKEN=xxx
CHATWOOT_ACCOUNT_ID=1
CHATWOOT_360DIALOG_INBOX_ID=xxx

OPENAI_API_KEY=sk-xxx
ANTHROPIC_API_KEY=sk-ant-xxx

SUPABASE_URL=https://xxx.supabase.co
SUPABASE_SERVICE_KEY=xxx

DIALOG_360_API_KEY=xxx
DIALOG_360_PHONE_ID=xxx

SECRET_KEY_BASE=$(openssl rand -hex 64)
DATABASE_URL=postgresql://...
REDIS_URL=redis://...

# White-label
BRAND_NAME="YourCompany CRM"
LOGO_THUMBNAIL=https://...
LOGO=https://...
```

---

## üìä MONITORING & OBSERVABILITY

### Key Metrics to Track
```python
# Metrics:
1. Messages processed per hour
2. Average response time (<3s target)
3. Human takeover rate (%)
4. RAG search rate (%)
5. Error rate (target <1%)
6. CRM update success rate (target >99%)

# Alerts:
- Response time >5s (5 consecutive)
- Error rate >5% (1 hour window)
- API failures (OpenAI, Anthropic, Supabase)
- Webhook downtime
```

### Railway Dashboard
```bash
# View logs
railway logs

# View metrics
railway metrics

# Monitor deployments
railway status
```

---

## üéØ SUCCESS CRITERIA

### Technical
- ‚úÖ All 4 agents working correctly
- ‚úÖ Agentic RAG searches knowledge base autonomously
- ‚úÖ CRM updates persist in Chatwoot
- ‚úÖ Multi-channel messaging works (WhatsApp, Instagram, Email)
- ‚úÖ Human takeover triggers correctly
- ‚úÖ Response time <3 seconds (95th percentile)
- ‚úÖ 99% uptime on Railway

### Business
- ‚úÖ 3 use cases tested end-to-end
- ‚úÖ White-label branding applied
- ‚úÖ Cost per client = ‚Ç¨115/month
- ‚úÖ 360Dialog production WhatsApp working
- ‚úÖ ScrapeCreators import working

### User Experience
- ‚úÖ AI summaries accurate (>90%)
- ‚úÖ Human can take over smoothly
- ‚úÖ Contact profiles show all data
- ‚úÖ No context lost between channels
- ‚úÖ GDPR compliant

---

## üîÆ FUTURE ENHANCEMENTS (Post-Launch)

### Month 3-6 Roadmap
1. **Next.js Analytics Dashboard** (if Chatwoot insufficient)
   - Sales pipeline visualization
   - Conversion rate tracking
   - Agent performance metrics

2. **Additional Channels**
   - Telegram integration
   - Facebook Messenger
   - SMS (Twilio)

3. **Advanced Features**
   - A/B testing for agent responses
   - Multi-language support
   - Voice message processing
   - Image recognition (for product inquiries)

4. **Integrations**
   - Zapier/Make webhooks
   - CRM export (Salesforce, HubSpot)
   - Calendar scheduling (Calendly)
   - Payment processing (Stripe)

---

## üìã TASK BREAKDOWN SUMMARY

### Week 1-2 (20 tasks)
- Chatwoot deployment (3 tasks)
- WhatsApp MCP integration (3 tasks)
- FastAPI webhook (4 tasks)
- Supabase PGVector (4 tasks)
- Docker Compose (2 tasks)
- Testing (4 tasks)

### Week 3-4 (18 tasks)
- LangGraph setup (3 tasks)
- Router agent (2 tasks)
- Extraction agent (2 tasks)
- Conversation agent (2 tasks)
- CRM agent (3 tasks)
- Integration (3 tasks)
- Testing (3 tasks)

### Week 5 (12 tasks)
- Knowledge base population (3 tasks)
- Vector embeddings (2 tasks)
- Agentic RAG implementation (4 tasks)
- Testing (3 tasks)

### Week 6 (15 tasks)
- Custom attributes (3 tasks)
- AI summaries (2 tasks)
- Lead classification (2 tasks)
- Human takeover (3 tasks)
- Multi-channel (2 tasks)
- Testing (3 tasks)

### Week 7 (20 tasks)
- 360Dialog integration (5 tasks)
- ScrapeCreators import (3 tasks)
- Rate limiting (2 tasks)
- GDPR compliance (4 tasks)
- Testing (6 tasks)

### Week 8 (18 tasks)
- White-label branding (4 tasks)
- Integration testing (3 tasks)
- Performance optimization (3 tasks)
- Production deployment (4 tasks)
- Monitoring (2 tasks)
- Final testing (2 tasks)

**TOTAL: 103 tasks across 8 weeks**

---

## üéì LEARNING RESOURCES

### Documentation Links
- [Chatwoot API Docs](https://www.chatwoot.com/developers/api)
- [LangGraph Guide](https://langchain-ai.github.io/langgraph/)
- [Pydantic AI Docs](https://ai.pydantic.dev/)
- [Claude API Reference](https://docs.anthropic.com/claude/reference)
- [Supabase PGVector](https://supabase.com/docs/guides/database/extensions/pgvector)
- [360Dialog API](https://docs.360dialog.com/)
- [Railway Deployment](https://docs.railway.app/)

### Recommended Tutorials
1. FastAPI async patterns
2. LangGraph state machines
3. Vector similarity search
4. WhatsApp Business API
5. Docker Compose multi-container apps

---

**END OF IMPLEMENTATION ROADMAP v5.1**

**Ready to build? Start with Week 1, Day 1!**

**Questions? Review PRD v5.1 or contact project lead.**

üöÄ **Let's build something amazing!**